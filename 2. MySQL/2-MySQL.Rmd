---
title: "Ciencia de Datos con R"
subtitle: "2. dplyr + database (db)"
author: "Ana Sustaita, sustaitaana@gmail.com"
output:
  html_document:
    df_print: paged
    highlight: tango
    theme: flatly
  pdf_document: default
  word_document: default
---

![](../images/greenshark.png)

# {.tabset .tabset-fade .tabset-pills}

## dplyr

 ![](../images/divide-aplica-combina.png)

`dplyr` a??ade muchas funciones para manipulaci??n de datos a trav??s de data frames, con un gran performance y backends para varias bases de datos. Nos permite manipular directamente tablas de una BD, sin escribir SQL, toda la evaluaci??n es lazy y, de ser posible, se realiza directamente en la BD.

Para estos ejemplos utilizaremos un data frame local (la tabla `mtcars` del paquete `dplyr`). M??s adelante veremos c??mo usar `dplyr` con bases de datos.

```{r, message=FALSE, warning=FALSE}
library(dplyr)
mtc <- tbl_df(mtcars)
mtc$car <- row.names(mtcars)
head(mtc)
```

Tambi??n usaremos el siguiente data frame de "juguete" para tener m??s ejemplos:

```{r, message=FALSE, warning=FALSE}
df_ej <- data.frame(genero = c("mujer", "hombre", "mujer", "mujer", "hombre"), 
                    estatura = c(1.65, 1.80, 1.70, 1.60, 1.67))
df_ej
```

### dplyr | select

En `dplyr` *select* se ocupa para seleccionar las columnas que queremos que formen parte de la respuesta.

![](../images/select_data.png)

```{r, message=FALSE, warning=FALSE}
mtc %>% select(car, cyl, mpg) %>%
  head()
```

```{r, message=FALSE, warning=FALSE}
df_ej
select(df_ej, genero)
select(df_ej, -genero)
```

```{r, eval = FALSE, message=FALSE, warning=FALSE}
select(df_ej, starts_with("g"))
select(df_ej, contains("g"))
```

### dplyr | filter

La funci??n *filter* permite filtrar un data frame por alguna condici??n que los renglones deban cumplir.

![](../images/filter_data.png)

```{r, message=FALSE, warning=FALSE}
mtc %>% select(car, cyl, mpg) %>%
  filter(cyl >= 6) %>%
  head()
```

Se puede hacer *filter* por m??s de una condici??n a la vez.

Aprovechemos para ver `%in%`

```{r, message=FALSE, warning=FALSE}
mtc %>% select(car, cyl, mpg) %>%
  filter(cyl %in% c(4,6)) %>%
  head()
```

```{r, message=FALSE, warning=FALSE}
filter(df_ej, genero == "mujer")
filter(df_ej, estatura > 1.65 & estatura < 1.75)
```

Algunos operadores importantes para filtrar son:

```{r, eval = FALSE, message=FALSE, warning=FALSE}
x > 1
x >= 1
x < 1
x <= 1
x != 1
x == 1
x %in% ("a", "b")

# Conjuntos
a | b
a & b
a & !b
xor(a, b)
```

### dplyr | arrange

Ocupamos *arrange* para ordenar los datos de acuerdo a alguna(s) columna(s), por default se ordenan de manera ascendente por lo que debemos indicar que lo queremos de manera descendente cuando as?? lo querramos y por cu??l columna vamos a ordenar.

```{r, message=FALSE, warning=FALSE}
mtc %>% select(car, cyl, mpg) %>%
  filter(cyl >= 6) %>%
  arrange(desc(mpg)) %>%
  head()
```

```{r, message=FALSE, warning=FALSE}
arrange(df_ej, genero)
arrange(df_ej, desc(estatura))
```

### dplyr | mutate

La funci??n *mutate* permite agregar una columna que no exist??a en el data frame original a partir de columnas que s?? pertenecen al data frame original.

```{r, message=FALSE, warning=FALSE}
mtc %>% select(car, cyl, mpg) %>%
  filter(cyl >= 6) %>%
  arrange(desc(mpg)) %>%
  mutate(kpl = 1.6/3.78*mpg) %>%
  head()
```

```{r, message=FALSE, warning=FALSE}
mutate(df_ej, estatura_cm = estatura * 100) 
mutate(df_ej, estatura_cm = estatura * 100, estatura_in = estatura_cm * 0.3937) 
```

### dplyr | group by + summarise

*group_by* agrupa un set de datos por alguna(s) columna(s), ocupamos *summarise* para aplicar alguna funci??n a cada grupo de datos, count(\*) es un `n()` en dplyr, tambi??n se puede sacar `mean()`, `sd()`, `median()`, una funci??n definida por nosotros, etc. Para unir todas las funciones ocupamos *magrittr* `%>%`.

```{r, message=FALSE, warning=FALSE}
mtc %>% 
  select(car, cyl, mpg) %>%
  filter(cyl >= 6) %>%
  arrange(desc(mpg)) %>%
  mutate(kpl = 1.6/3.78*mpg) %>%
  group_by(cyl) %>%
  dplyr::summarise(mean.kpl = mean(kpl), n = n())
```

La salida de `group by` regresa las cosas ordenadas alfab??ticamente -por la columna con la que hizo agrupaci??n-.

Las operaciones que se realizan despu??s de `group_by` se aplican a cada grupo por separado. e.g. `arrange` organiza las filas dentro de cada grupo por las columnas indicadas.

Summarise solo sirve para crear nuevas bases de datos con res??menes o agregaciones de los datos originales.

```{r, message=FALSE, warning=FALSE}
dplyr::summarise(df_ej, promedio = mean(estatura))
```

Podemos crear solamente una base de datos agrupada:
  
```{r}
by_genero <- group_by(df_ej, genero)
by_genero
```

y despu??s operar sobre cada grupo, creando un resumen a nivel grupo y uniendo los subconjuntos en una base nueva:
  
```{r, message=FALSE, warning=FALSE}
dplyr::summarise(by_genero, promedio = mean(estatura))
```

Algunas funciones ??tiles con _summarise_ son `min(x)`, `median(x)`, `max(x)`, `quantile(x, p)`, `n()`, `sum(x)`, `sum(x > 1)`, `mean(x > 1)`, `sd(x)`.


<div style="background-color:#ffcf40">
**Nota importante: existen conflictos con la funci??n summarise. Por lo tanto, puede ser necesario indicar que se debe utilizar la funci??n summarise del paquete dplyr. Esto se hace anteponiendo a la llamada de la funci??n dos s??mbolos de 'dos puntos' :: y antecediendo el nombre del paquete que se desea utilizar, en este caso, dplyr. A veces se necesita hacer lo mismo con la funci??n mutate. La raz??n de esto es que hay un conflicto entre los paquetes plyr y dplyr. En principio, plyr ya no se usa porque dplyr es la versi??n nueva (y mejor) de plyr. Pero aqu?? usamos este paquete para hacer uso de las funciones laply, dlply, y ldply. **
</div>


#### Variables por grupo

En ocasiones es conveniente crear variables por grupo, por ejemplo estandarizar dentro de cada grupo z = (x - mean(x)) / sd(x).

Veamos un ejemplo:

```{r, message=FALSE, warning=FALSE}
mtcars_tmp <- mtcars %>%
  group_by(cyl) %>%
  filter(n() > 10)

mtcars_2 <- mtcars_tmp %>%
  mutate(z_mpg = (mpg - mean(mpg)) / sd(mpg)) %>%
  filter(z_mpg > 0.5)

mtcars_2
```

### dplyr | join

```{r, message=FALSE, warning=FALSE} 
cyls <- mtc %>% select(car, cyl) %>% sample_n(20)
mpgs <- mtc %>% select(car, mpg) %>% sample_n(20)
inner_join(mpgs, cyls) %>% head()
```

Hay varias maneras de unir dos bases de datos y debemos pensar en el objetivo:

```{r, message=FALSE, warning=FALSE}
x <- data.frame(name = c("John", "Paul", "George", "Ringo", "Stuart", "Pete"),
                instrument =c("guitar", "bass", "guitar", "drums", "bass", "drums"))

y <- data.frame(name = c("John", "Paul", "George", "Ringo", "Brian"),
                band = c("TRUE", "TRUE", "TRUE",  "TRUE", "FALSE"))
x
y

inner_join(x, y, by = 'name')
left_join(x, y)
semi_join(x, y)
anti_join(x, y)
```

Resumamos lo que observamos arriba:

Tipo | Acci??n
-----|-------
inner|Incluye ??nicamente las filas que aparecen tanto en x como en y
left |Incluye todas las filas en x y las filas de y que coincidan
semi |Incluye las filas de x que coincidan con y
anti |Incluye las filas de x que no coinciden con y


##### Ejercicios

1. ??Qu?? personajes son droides?

2. Muestra el color de cabello, piel y ojos de los personajes femeninos

3. Calcula el ??ndice de masa corporal de cada personaje 

    ![](../images/pointer.png) $bmi=\frac{mass(kg)}{height^{2}(m)}$

4. ??Cu??les son los 5 personajes m??s pesados?

5. ??Cu??ntos personajes de cada especie hay? ??Cu??l es el promedio de peso de cada especie? Muestra esta informaci??n de aquellas especies que tengan m??s de 1 personaje.

##### <-- Respuestas -->

```{r, message=FALSE, warning=FALSE}
# 1. ??Qu?? personajes son droides?
starwars %>% 
  filter(species == "Droid")

# 2. Muestra el color de cabello, piel y ojos de los personajes femeninos
starwars %>% 
  filter(gender == "female") %>% 
  select(name, ends_with("color")) 

# 3. Calcula el ??ndice de masa corporal de cada personaje
starwars %>% 
  mutate(name, bmi = mass / ((height / 100)  ^ 2)) %>%
  select(name:mass, bmi)

# 4. ??Cu??les son los 5 personajes m??s pesados?
starwars %>% 
  arrange(desc(mass)) %>% 
  head(5)

# 5. ??Cu??ntos personajes de cada especie hay? ??Cu??l es el promedio de peso de cada especie? Muestra esta informaci??n de aquellas especies que tengan m??s de 1 personaje.
starwars %>%
  group_by(species) %>%
  summarise(
    n = n(),
    mass = mean(mass, na.rm = TRUE)
  ) %>%
  filter(n > 1, !is.na(species))
```


## R db + dplyr

### Datos Relacionales

Es raro que un an??lisis de datos involucre solo una tabla de datos. Normalmente tiene muchas y debemos combinarlas para responder a las preguntas que nos interesan. En conjunto, las tablas m??ltiples de datos se denominan datos relacionales porque son las relaciones, no solo los conjuntos de datos individuales, las que son importantes.

Las relaciones siempre se definen entre un par de tablas. Todas las dem??s relaciones se construyen a partir de esta idea simple: las relaciones de tres o m??s tablas son siempre una propiedad de las relaciones entre cada par. ??A veces ambos elementos de un par pueden ser la misma tabla! Esto es necesario si, por ejemplo, tenemos una tabla de personas, y cada persona tiene una referencia a sus padres.

Para trabajar con datos relacionales necesitas verbos que funcionen con pares de tablas. Hay tres familias de verbos dise??ados para trabajar con datos relacionales:

+ **Mutating joins** que agrega nuevas variables a un marco de datos de observaciones coincidentes en otro.

+ **Filtering joins** que filtran las observaciones de un marco de datos seg??n si coinciden o no con una observaci??n en la otra tabla.

+ **Set operations** que tratan las observaciones como si fueran elementos establecidos.

Exploraremos los datos relacionales de la base de datos `nycflights13` haciendo uso de los verbos de dos tablas de `dplyr`.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(nycflights13)
```

Usaremos el paquete `nycflights13` para aprender sobre datos relacionales. Contiene cuatro tibbles que est??n relacionados con la `flights`.

`airlines` nos permite buscar el nombre completo de la empresa a partir de su c??digo abreviado:

```{r, message=FALSE, warning=FALSE}
airlines
```


`airports` brinda informaci??n sobre cada aeropuerto, identificado por el c??digo `faa` del aeropuerto:

```{r, message=FALSE, warning=FALSE}
airports
```

`planes` brinda informaci??n sobre cada avi??n, identificado por su `tailnum`:

```{r, message=FALSE, warning=FALSE}
planes
```

`weather` da el clima en cada aeropuerto de Nueva York por cada hora:

```{r, message=FALSE, warning=FALSE}
weather
```

Una forma de mostrar las relaciones entre las diferentes tablas es con un diagrama:

![](../images/relational-nycflights.png)

Este diagrama es un poco abrumador, ??pero es simple comparado con algunos que ver??s en la vida real! La clave para entender diagramas como este es recordar que cada relaci??n siempre se encuentra entre un par de tablas. S??lo necesitamos comprender la cadena de relaciones entre las tablas que nos interesan.

Para `nycflights13`:

+ `flights` se conecta a `planes` a trav??s de una ??nica variable, `tailnum`.

+ `flights` se conecta a `airlines` a trav??s de la variable `carrier`.

+ `flights` se conecta a `airports` de dos maneras: a trav??s de las variables `origin` y `dest`.

+ `flights` se conecta a `weather` a trav??s de `origin` (la ubicaci??n), y `year`, `month`, `day` y `hour` (el tiempo).

#### Ejercicios

1. Imagina que deseas dibujar (aproximadamente) la ruta que cada avi??n vuela desde su origen hasta su destino. ??Qu?? variables necesitar??as? ??Qu?? tablas necesitar??as combinar?

2. Olvid?? dibujar la relaci??n entre `weather` y `airports`. ??Cu??l es la relaci??n y c??mo deber??a aparecer en el diagrama?

3. `weather` s??lo contiene informaci??n para los aeropuertos de origen (NYC). Si contuviera registros del clima para todos los aeropuertos de EUA, ??Con qu?? relaci??n adicional definir??as `flights`?

4. Sabemos que algunos d??as del a??o son "especiales", y menos personas de lo habitual vuelan en estos. ??C??mo podr??a representar esos datos como un marco de datos? ??Cu??les ser??an las llaves principales en esa tabla? ??C??mo se conectar??a con las tablas existentes?

### Llaves
Las variables utilizadas para conectar cada par de tablas se llaman llaves. Una llave es una variable (o conjunto de variables) que identifica de manera ??nica una observaci??n. En casos simples, una sola variable es suficiente para identificar una observaci??n. Por ejemplo, cada avi??n est?? identificado de manera ??nica por su `tailnum`. En otros casos, pueden ser necesarias m??ltiples variables. Por ejemplo, para identificar una observaci??n en `weather` necesitamos cinco variables: `year`, `month`, `day`, `hour`, y `origin`.

Hay dos tipos de llaves:

+ Una **llave primaria** identifica de manera ??nica una observaci??n en su propia tabla. Por ejemplo, `planes$tailnum` es una llave primaria porque identifica de forma ??nica cada avi??n en la tabla `planes`.

+ Una **llave for??nea** identifica de forma ??nica una observaci??n en otra tabla. Por ejemplo, el `flights$tailnum` es una llave for??nea porque aparece en la tabla `flights` donde coincide cada vuelo con un avi??n ??nico.

Una variable puede ser tanto una llave primaria como una llave for??nea. Por ejemplo, `origin` es parte de la llave primaria de `weather` y tambi??n es una llave for??nea para la tabla `airports`.

Una vez que hayamos identificado las llaves primarias en las tablas, es una buena pr??ctica verificar que s?? identifiquen de manera ??nica cada observaci??n. Una forma de hacerlo es contando las llaves primarias con `count()` y buscar las entradas donde `n` es mayor que uno:

```{r, message=FALSE, warning=FALSE}
planes %>% 
  count(tailnum) %>% 
  filter(n > 1)

weather %>% 
  count(year, month, day, hour, origin) %>% 
  filter(n > 1)
```

Algunas veces, una tabla no tiene una llave primaria expl??cita: cada fila es una observaci??n, pero ninguna combinaci??n de variables la identifica de manera confiable. Por ejemplo, ??cu??l es la llave primaria en la tabla `flights`? Podemos pensar que ser??a la fecha m??s el n??mero de vuelo o cola, pero ninguno de los dos es ??nico:

```{r, message=FALSE, warning=FALSE}
flights %>% 
  count(year, month, day, flight) %>% 
  filter(n > 1)

flights %>% 
  count(year, month, day, tailnum) %>% 
  filter(n > 1)
```

A primera vista, con estos datos, ingenuamente asumir??amos que cada n??mero de vuelo solo se usar??a una vez al d??a: eso har??a mucho m??s f??cil comunicar problemas con un vuelo espec??fico. ??Desafortunadamente, ese no es el caso! 

Si una tabla carece de una llave primaria, puede ser ??til agregar una usando las funciones `mutate()` y `row_number()`. Eso vuelve m??s f??cil hacer coincidir las observaciones si hemos realizado alg??n tipo de filtrado y deseamos volver a verificar con los datos originales. Esto se llama una **llave sustituta**.

Una llave primaria y la llave for??nea correspondiente en otra tabla forman una relaci??n. Las relaciones son t??picamente de uno a muchos. Por ejemplo, cada vuelo tiene un avi??n, pero cada avi??n tiene muchos vuelos. En otros datos, ocasionalmente veremos una relaci??n de 1 a 1. Puedes pensar en esto como un caso especial de 1 a muchos. Podemos modelar relaciones de muchos a muchos con una relaci??n de varios a uno m??s una relaci??n de uno a varios. Por ejemplo, en esta informaci??n existe una relaci??n de muchos a muchos entre aerol??neas y aeropuertos: cada l??nea a??rea vuela a muchos aeropuertos, cada aeropuerto alberga muchas l??neas a??reas.

#### Ejercicios

1. Agrega una llave sustituta a `flights`.

2. Identifica las llaves en los siguientes conjuntos de datos (es posible que necesites instalar algunos paquetes y leer cierta documentaci??n).

```{r, message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE}
Lahman::Batting,
babynames::babynames
nasaweather::atmos
fueleconomy::vehicles
ggplot2::diamonds
```

3. Dibuja un diagrama que ilustre las conexiones entre las tablas `Batting`, `Mastery Salaries` en el paquete `Lahman`. Dibuja otro diagrama que muestre la relaci??n entre `Master`, `Managers`, `AwardsManagers`.

4. ??C??mo caracterizar??as la relaci??n entre las tablas `Batting`, `Pitching` y `Fielding`?

### Mutating Joins

La primera herramienta que veremos para combinar un par de tablas es la **uni??n mutante**. Esto permite combinar variables de dos tablas. En primer lugar, hace coincidir las observaciones con sus llaves, luego copia las variables de una tabla a la otra.

Por ejemplo `mutate()`, las funciones de uni??n agregan variables a la derecha, por lo que si ya tiene muchas variables, las nuevas variables no se imprimir??n. Para estos ejemplos, haremos que sea m??s f??cil ver lo que est?? sucediendo en los ejemplos mediante la creaci??n de un conjunto de datos m??s estrecho:

```{r, message=FALSE, warning=FALSE}
flights2 <- flights %>% 
  select(year:day, hour, origin, dest, tailnum, carrier)
flights2
```

Imaginemos que deseamos agregar el nombre completo de la l??nea a??rea a los datos `flights2`. Podemos combinar las tablas `airlines` y `flights2` `left_join()`:

```{r}
flights2 %>%
  select(-origin, -dest) %>% 
  left_join(airlines, by = "carrier")
```

El resultado de la uni??n de las compa????as a??reas `flights2` es una variable adicional: `name`. Es por eso que llamamos a este tipo de uni??n como uni??n mutante. En este caso, podr??amos haber llegado al mismo lugar usando `mutate()`:

```{r}
flights2 %>%
  select(-origin, -dest) %>% 
  mutate(name = airlines$name[match(carrier, airlines$carrier)])
```

Pero esto es dif??cil de generalizar cuando necesitamos hacer coincidir m??ltiples variables.

#### Uniones

Para ayudarnos a aprender c??mo funcionan las uniones, usaremos una representaci??n visual:

![](../images/join-setup.png)


```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)
```

La columna de color representa la variable "llave": se utilizan para hacer coincidir las filas entre las tablas. La columna gris representa la columna de "valor" que se va arrastrando a trav??s de las uniones. En estos ejemplos, mostrarmos una sola variable llave, pero la idea se generaliza de forma directa a varias llaves y valores m??ltiples.

Una uni??n es una forma de conectar cada fila en `x` a cero, una o m??s filas en `y`. El siguiente diagrama muestra cada coincidencia potencial como una intersecci??n de un par de l??neas.

![](../images/join-setup2.png)

(Si observamos detenidamente, podemos ver que hemos cambiado el orden de las columnas de llave y valor en `x`. Esto es para enfatizar que las uniones coinciden en funci??n de la llave, el valor s??lo se arrastra en el camino).

En una uni??n real, las coincidencias se indicar??n con puntos. El n??mero de puntos es igual al n??mero de coincidencias que es igual al n??mero de filas en la salida.

![](../images/join-inner.png)

##### Inner Join

El tipo m??s simple de uni??n es la uni??n interna. Una uni??n interna une pares de observaciones cuando sus llaves son iguales:

![](../images/join-inner.png)

(Para ser precisos, se trata de una equiunidad interna porque las llaves se combinan utilizando el operador de igualdad. Como la mayor??a de las combinaciones son equivalentes, por lo general descartamos esa especificaci??n).

El resultado de una uni??n interna es un nuevo marco de datos que contiene la llave, los valores de `x` y los valores de `y`. Usamos `by` para decirle a `dplyr` qu?? variable es la llave:

```{r, message=FALSE, warning=FALSE}
x %>% 
  inner_join(y, by = "key")
```

La propiedad m??s importante de una uni??n interna es que las filas no coincidentes no se incluyen en el resultado. Esto significa que generalmente las combinaciones internas no son apropiadas para usar en el an??lisis porque es muy f??cil perder las observaciones.

##### Outer Join

Una uni??n interna mantiene las observaciones que aparecen en ambas tablas. Una uni??n externa mantiene observaciones que aparecen en al menos una de las tablas. Hay tres tipos de uniones externas:


+ **left_join** mantiene todas las observaciones de `x`.
+ **right_join** mantiene todas las observaciones de `y`.
+ **full_join** mantiene todas las observaciones de `x` y `y`.


Estas uniones funcionan agregando una observaci??n "virtual" adicional a cada tabla. Esta observaci??n tiene una llave que siempre coincide (si no hay otra llave que coincida) y un valor lleno con `NA`.

Gr??ficamente, eso se ve as??:

![](../images/join-outer.png)

La uni??n m??s com??nmente utilizada es left_join: la usamos cada vez que buscamos datos adicionales de otra tabla, ya que conserva las observaciones originales incluso cuando no coinciden. La uni??n izquierda debe ser tu uni??n predeterminada: ??senla a menos que tengan una buena raz??n para preferir una de las otras.

Otra forma de representar los diferentes tipos de uniones es con un diagrama de Venn:


![](../images/join-venn.png)

Sin embargo, esta no es una gran representaci??n. Puede ayudar a nuestra memoria sobre qu?? uni??n conserva las observaciones en qu?? tabla, pero adolece de una limitaci??n importante: un diagrama de Venn no puede mostrar lo que sucede cuando las llaves no identifican de manera ??nica una observaci??n.

##### LLaves Duplicadas

Hasta ahora, todos los diagramas han supuesto que las llaves son ??nicas. Pero ese no es siempre el caso. A continuaci??n veremos qu?? sucede cuando las llaves no son ??nicas. Hay dos posibilidades:

1. Una tabla tiene llaves duplicadas. Esto es ??til cuando se desea agregar informaci??n adicional, ya que normalmente hay una relaci??n de uno a varios.

![](../images/join-one-to-many.png)


Notemos que la columna llave est?? en una posici??n ligeramente diferente en la salida. Esto refleja que la llave es una llave primaria en `y` y una llave for??nea en `x`.


```{r, message=FALSE, warning=FALSE}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     1, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2"
)
left_join(x, y, by = "key")
```

2. Ambas tablas tienen llaves duplicadas. Esto suele ser un error porque en ninguna de las tablas las llaves identifican de manera ??nica una observaci??n. Cuando unimos llaves duplicadas, obtenemos todas las combinaciones posibles, el producto cartesiano:


![](../images/join-semi-many.png)


```{r, message=FALSE, warning=FALSE}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     3, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     2, "y3",
     3, "y4"
)
left_join(x, y, by = "key")
```


#### Definir las columnas llave

Hasta ahora, los pares de tablas siempre han estado unidos por una sola variable, y esa variable tiene el mismo nombre en ambas tablas. Esa restricci??n fue codificada por `by = "key"`. Podemos usar otros valores de `by` para conectar las tablas de otras formas:


+ El predeterminado, `by = NULL` usa todas las variables que aparecen en ambas tablas, la llamada uni??n **natural**. Por ejemplo, las tablas `flights` y `weather` coinciden en sus variables comunes: `year`, `month`, `day`, `hour` y `origin`.


```{r, message=FALSE, warning=FALSE}
flights2 %>% 
  left_join(weather)
```



+ Un vector de caracteres, `by = "x"`. Esto es como una uni??n natural, pero usa solo algunas de las variables comunes. Por ejemplo, `flights` y `planes` tienen la variable `year`, pero significan cosas diferentes, por lo que solo queremos unirlas por `tailnum`.


```{r, message=FALSE, warning=FALSE}
flights2 %>% 
  left_join(planes, by = "tailnum")
```


Notemos que las variables `year` (que aparecen en ambas tablas de entrada, pero no est??n obligadas a ser iguales) se desambiguan en la salida con un sufijo.


+ Un vector de caracteres nombrado: `by = c("a" = "b")`. Esto har?? coincidir la variable `a` en la tabla `x` con la variable `b` en la tabla `y`. Las variables de `x` se usar??n en la salida.

Por ejemplo, si queremos dibujar un mapa, necesitamos combinar los datos de los vuelos con los datos de los aeropuertos que contienen la ubicaci??n (`lat` y `lon`) de cada aeropuerto. Cada vuelo tiene un aeropuerto de origen y uno de destino, por lo que debemos especificar con cu??l queremos unir:


```{r, message=FALSE, warning=FALSE}
flights2 %>% 
  left_join(airports, c("dest" = "faa"))
```

```{r, message=FALSE, warning=FALSE}
flights2 %>% 
  left_join(airports, c("origin" = "faa"))
```


### Filtrado de uniones

El filtrado une las observaciones de coincidencia de la misma forma que las uniones mutantes, pero afecta las observaciones, no las variables. Hay dos tipos:


+ `semi_join(x, y)` **mantiene** todas las observaciones en `x` que tienen una coincidencia en `y`.

+ `anti_join(x, y)` **descarta** todas las observaciones en `x` que tienen una coincidencia en `y`.


Las semiuniones son ??tiles para hacer coincidir las tablas de resumen filtradas con las filas originales. Por ejemplo, imaginemos que hemos encontrado los diez destinos m??s populares:

```{r, message=FALSE, warning=FALSE}
top_dest <- flights %>%
  count(dest, sort = TRUE) %>%
  head(10)
top_dest
```


Ahora queremos encontrar cada vuelo que fue a uno de esos destinos. Nosotros mismos podemos construir un filtro:

```{r, message=FALSE, warning=FALSE}
flights %>% 
  filter(dest %in% top_dest$dest)
```

Pero es dif??cil extender ese enfoque a m??ltiples variables. Por ejemplo, imaginemos que encontramos los 10 d??as con las demoras promedio m??s altas. ??C??mo constru??mos la instrucci??n de filtro que utiliza `year`, `month` y  `day` para que coincida de nuevo con `flights`?

En su lugar, podemos usar una semi uni??n, que conecta las dos tablas como una uni??n mutante, pero en lugar de agregar nuevas columnas, solo conserva las filas de `x` que tienen una coincidencia en `y`:


```{r, message=FALSE, warning=FALSE}
flights %>% 
  semi_join(top_dest)
```


Gr??ficamente, una semi-uni??n se ve as??:

![](../images/join-semi.png)

La sola existencia de una coincidencia es importante, no importa qu?? observaci??n coincida. Esto significa que las uniones de filtro nunca duplican las filas como lo hacen las uniones mutantes:


![](../images/join-semi-many.png)


El inverso de una semi uni??n es una anti uni??n. Un `anti_join` mantiene las filas que no tienen una coincidencia:

![](../images/join-anti.png)


Las anti uniones son ??tiles para diagnosticar desajustes de uni??n. Por ejemplo, al conectar `flights` y `planes`, es posible que nos interese saber que hay muchos `flights` que no coinciden en `planes`:


```{r, message=FALSE, warning=FALSE}
flights %>%
  anti_join(planes, by = "tailnum") %>%
  count(tailnum, sort = TRUE)
```


### Problemas de Uni??n

La informaci??n con la que hemos estado trabajando est?? limpia. Es poco probable que los datos a los que te enfrentes en la vida real sean tan agradables, por lo que hay algunas cosas que debes hacer para que las uniones funcionen sin problemas.


1. Comienza por identificar las variables que forman la llave principal en cada tabla. Por lo general, debes hacer esto en funci??n de tu comprensi??n de los datos y no emp??ricamente buscando una combinaci??n de variables que proporcionen un identificador ??nico. Si solo buscas variables sin pensar en lo que significan, puedes ser (o no) afortunado y encontrar una combinaci??n que sea ??nica en los datos, pero la relaci??n podr??a no ser cierta en general.
Por ejemplo, la altitud y la longitud identifican de manera ??nica cada aeropuerto, ??pero no son buenos identificadores!


```{r, message=FALSE, warning=FALSE}
airports %>% count(alt, lon) %>% filter(n > 1)
```


2. Comprueba que no falte ninguna de las variables en la llave primaria. Si falta un valor, ??no puede identificar una observaci??n!


3. Verifica que las llaves for??neas coincidan con las llaves primarias en otra tabla. La mejor manera de hacerlo es con un `anti_join()`. Es com??n que las llaves no coincidan debido a errores de entrada de datos. Reparar estos a menudo es mucho trabajo.
Si tienes llaves faltantes, deber??s considerar cuidadosamente el uso de combinaciones internas y externas, teniendo en cuenta cuidadosamente si deseas colocar filas que no coincidan.


Debemos tener en cuenta que simplemente verificar el n??mero de filas antes y despu??s de la uni??n no es suficiente para garantizar que la uni??n se haya realizado sin problemas. Si tenemos una uni??n interna con llaves duplicadas en ambas tablas, es posible que tengamos mala suerte, ya que la cantidad de filas descartadas puede ser exactamente igual a la cantidad de filas duplicadas.

### Operaciones de Conjuntos

El tipo final de verbo de dos tablas son las operaciones de conuntos. En general, se utilizan con menos frecuencia pero ocasionalmente son ??tiles cuando se quiere dividir un solo filtro complejo en piezas m??s simples. Todas estas operaciones funcionan con una fila completa, comparando los valores de cada variable. Estos esperan que las entradas en `x` y las entradas en `y` tengan las mismas variables y tratan las observaciones como conjuntos:


+ `intersect(x, y)`: solo devuelve observaciones en ambos `x` y `y`.

+ `union(x, y)`: devuelve observaciones ??nicas en `x` y `y`.

+ `setdiff(x, y)`: devuelve observaciones en `x`, pero no en `y`.


Si tomamos estos datos simples:

```{r, message=FALSE, warning=FALSE}
df1 <- tribble(
  ~x, ~y,
   1,  1,
   2,  1
)
df2 <- tribble(
  ~x, ~y,
   1,  1,
   1,  2
)
```

Las cuatro posibilidades son:

```{r, message=FALSE, warning=FALSE}
intersect(df1, df2)
```

Notemos aqu?? que obtenemos 3 filas, no 4:

```{r, message=FALSE, warning=FALSE}
union(df1, df2)
```

```{r, message=FALSE, warning=FALSE}
setdiff(df1, df2)
```

```{r, message=FALSE, warning=FALSE}
setdiff(df2, df1)
```


## MySQL db + dplyr

Para conectarnos a una base de datos, necesitamos 4 p??rametros (adem??s del nombre de la base de datos):

+ **host**: el IP del servidor en el que se encuentra la base de datos 
+ **port**: por default, MySQL usa el puerto 3306
+ **user**: es el usuario asignado por el administrador de la base de datos
+ **password**: contrase??a para acceder a la base de datos

```{r, message=FALSE, warning=FALSE}
library(pool)
library(DBI)
library(RMySQL)

db.host <- '127.0.0.1'
db.user <- 'root'
db.port <- 3306

## DB Connection
db_connect <- function(db.name) {
  db <- dbPool(
    drv = RMySQL::MySQL(),
    dbname = db.name,
    host = db.host,
    user = db.user,
    #password = db.password,
    port = as.numeric(db.port)
  )
  
  return(db)
}
```

Podemos agregar una tabla (o varias) a la base de datos usando las mismas credenciales con las que nos conectamos a ella con la funci??n `copy_to()`:

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
copy_to(
  db_connect('nycflights'), 
  nycflights13::flights, 
  "flights",
  temporary = FALSE, 
  indexes = list(
    c("year", "month", "day"), 
    "carrier", 
    "tailnum",
    "dest"
  )
)
```

Ahora que hemos copiado los datos, podemos utilizar `tbl()` para referenciarlos:

```{r, message=FALSE, warning=FALSE}
flights_db <- tbl(db_connect('nycflights'), "flights")
```

Cuando lo imprimimos, notamos que en su mayor??a se ve como un tibble normal:

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
flights_db 
# Source:   table<flights> [?? x 19]
# Database: mysql 10.1.33-MariaDB
#   [root@127.0.0.1:/nycflights]
#     year month   day dep_time sched_dep_time dep_delay
#    <int> <int> <int>    <int>          <int>     <dbl>
#  1  2013     1     1      517            515      2.00
#  2  2013     1     1      533            529      4.00
#  3  2013     1     1      542            540      2.00
#  4  2013     1     1      544            545     -1.00
#  5  2013     1     1      554            600     -6.00
#  6  2013     1     1      554            558     -4.00
#  7  2013     1     1      555            600     -5.00
#  8  2013     1     1      557            600     -3.00
#  9  2013     1     1      557            600     -3.00
# 10  2013     1     1      558            600     -2.00
# ... with more rows, and 13 more variables: arr_time <int>,
#   sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,
#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>,
#   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>,
#   time_hour <chr>
```

La principal diferencia es que puede ver que es una fuente remota en una base de datos MySQL.

### Generando consultas

Para interactuar con una base de datos, generalmente usamos SQL, el lenguaje de consulta estructurado. SQL tiene m??s de 40 a??os y es utilizado por pr??cticamente todas las bases de datos existentes. 

El objetivo de `dplyr` y `dbplyr` es generar autom??ticamente SQL para que no estemos obligados a usarlo. Sin embargo, SQL es un lenguaje muy grande y `dbplyr` no puede hacerlo todo. Se centra en la cl??usula `SELECT`.

La mayor??a de las veces no necesitamos saber nada sobre SQL y podemos continuar usando los verbos `dplyr` con los que ya estamos familiarizados:

```{r, message=FALSE, warning=FALSE}
flights_db %>% select(year:day, dep_delay, arr_delay)

flights_db %>% filter(dep_delay > 240)

flights_db %>% 
  group_by(dest) %>%
  summarise(delay = mean(dep_time))
```


Sin embargo, a largo plazo, puede ser buena idea aprender los conceptos b??sicos de SQL. Es una habilidad valiosa para cualquier cient??fico de datos.

La diferencia m??s importante entre marcos de datos comunes y consultas de bases de datos remotas es que nuestro c??digo R se traduce a SQL y se ejecuta en la base de datos, no en R. Al trabajar con bases de datos, `dplyr` intenta ser lo m??s flojo posible:

+ Nunca extrae datos en R a menos que lo solicitemos expl??citamente.

+ Retrasa la realizaci??n de cualquier trabajo hasta el ??ltimo momento posible: recopila todo lo que desea hacer y luego lo env??a a la base de datos en un solo paso.
  
Por ejemplo, veamos el siguiente c??digo:

```{r, message=FALSE, warning=FALSE}
tailnum_delay_db <- flights_db %>% 
  group_by(tailnum) %>%
  summarise(
    delay = mean(arr_delay),
    n = n()
  ) %>% 
  arrange(desc(delay)) %>%
  filter(n > 100)
```


Sorprendentemente, esta secuencia de operaciones nunca toca la base de datos. No es hasta que solicitamos los datos (por ejemplo, mediante la impresi??n `tailnum_delay_db`) que `dplyr` genera la consulta de SQL y solicita los resultados a la base de datos. Incluso entonces intenta hacer el menor trabajo posible y solo regresa unas pocas filas.

```{r, message=FALSE, warning=FALSE, eval=FALSE, include=TRUE}
tailnum_delay_db
# Source:     lazy query [?? x 3]
# Database:   mysql 10.1.33-MariaDB
#   [root@127.0.0.1:/nycflights]
# Ordered by: desc(delay)
#    tailnum delay     n
#    <chr>   <dbl> <dbl>
#  1 <NA>    NA     2512
#  2 N0EGMQ   9.98   371
#  3 N10156  12.7    153
#  4 N10575  20.7    289
#  5 N11106  14.9    129
#  6 N11107  15.0    148
#  7 N11109  14.9    148
#  8 N11113  15.8    138
#  9 N11119  30.3    148
# 10 N11121  10.3    154
# ... with more rows
```

Detr??s de escena, `dplyr` est?? traduciendo nuestro c??digo R en SQL. Podemos ver la consulta SQL que est?? generando con `show_query()`:

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
tailnum_delay_db %>% show_query()

<SQL>
SELECT *
FROM (SELECT *
FROM (SELECT `tailnum`, AVG(`arr_delay`) AS `delay`, count(*) AS `n`
FROM `flights`
GROUP BY `tailnum`) `ibfilopqjv`
ORDER BY `delay` DESC) `pjjxdobtkv`
WHERE (`n` > 100.0)
```

Probablemente no es exactamente lo que escribir??amos a mano si hici??ramos la consulta directo en SQL, pero cumple su funci??n. Podemos obtener m??s informaci??n sobre la traducci??n a SQL en `vignette("sql-translation")`.

Normalmente, repetiremos varias veces antes de averiguar qu?? datos necesitamos realmente de la base de datos. Una vez que lo hayamos descifrado, debemos usar `collect()` para guardar todos los datos a un `tibble` o `data.frame` local:

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
tailnum_delay <- tailnum_delay_db %>% collect()
tailnum_delay
# A tibble: 1,201 x 3
#    tailnum delay     n
#    <chr>   <dbl> <dbl>
#  1 <NA>    NA     2512
#  2 N0EGMQ   9.98   371
#  3 N10156  12.7    153
#  4 N10575  20.7    289
#  5 N11106  14.9    129
#  6 N11107  15.0    148
#  7 N11109  14.9    148
#  8 N11113  15.8    138
#  9 N11119  30.3    148
# 10 N11121  10.3    154
# ... with 1,191 more rows
```


`collect()` requiere que la base de datos haga algo de trabajo, por lo que puede llevar mucho tiempo completarla. De lo contrario, `dplyr` intenta evitar que realice accidentalmente costosas operaciones de consulta por dos motivos:

+ Porque generalmente no hay forma de determinar cu??ntas filas devolver?? una consulta a menos que realmente la ejecutemos, `nrow()` siempre nos regresa `NA`.

+ Como no puede encontrar las ??ltimas filas sin ejecutar toda la consulta, no podemos usar `tail()`.

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
nrow(tailnum_delay_db)
# [1] NA

tail(tailnum_delay_db)
# Error: tail() is not supported by sql sources
```


Tambi??n podemos preguntar a la base de datos c??mo planea ejecutar la consulta, usando `explain()`. El resultado depende de la base de datos, y puede ser medio esot??rico, pero aprender un poco al respecto puede ser muy ??til porque nos ayuda a entender si la base de datos puede ejecutar consultas de manera eficiente, o si necesitamos crear nuevos ??ndices.


## Ejercicios

1. ??Cu??l es el aeropuerto con mayor tr??fico de entrada? (vuelos diferentes) Ocupa en tu respuesta el nombre del aeropuerto (`join`)

2. Encuentra los vuelos con un retraso mayor a una hora.

3. Encuentra los vuelos en los que el retraso de llegada es m??s del doble que el retraso de salida.

4. Ve la ayuda de select (`?select`) y escribe tres
maneras de seleccionar las variables de retraso (delay).

5. ??Cu??l es la aerol??nea con mayor retraso de salida por d??a de la semana? `departure_delay`

6. ??Qu?? aerol??nea deber??amos tomar para tener la menor demora posible para llegar a Detroit? (ocupa `arrival_delay` como m??trica, por qu?? ocupar esa variable?) 

7. Calcula la velocidad en millas por hora a partir de
la variable tiempo y la distancia (en millas). ??Qu?? vuelo fue el m??s r??pido?

8. Crea una nueva variable que muestre cu??nto tiempo se gan?? o perdi?? durante el vuelo. ??Qu?? vuelos _ganaron_ m??s tiempo en el aire?

9. Calcula el retraso de llegada promedio por fecha.

10. ??Qu?? vuelos (compa????a + vuelo) ocurren diario?

11. En promedio, ??c??mo var??an a lo largo del d??a los retrasos de vuelos no cancelados? (pista: hour + minute / 60)

12. ??En qu?? d??a de la semana se tienen menor cantidad de retrasos de salida por aeropuerto?

13. ??Cu??l es la 32va aerol??nea con mayor diversidad de vuelos de entrada? Utiliza `rank`

14. Explora si los aviones m??s viejos est??n asociados a mayores retrasos, responde con una gr??fica.

15. Calcula el retraso promedio por destino, luego une con la tabla `airports` para que puedas mostrar la distribuci??n espacial de los retrasos. Aqu?? hay una manera f??cil de dibujar un mapa de los Estados Unidos:


```{r, message=FALSE, warning=FALSE, eval=FALSE, echo=TRUE}
airports %>%
  semi_join(flights, c("faa" = "dest")) %>%
  ggplot(aes(lon, lat)) +
    borders("state") +
    geom_point() +
    coord_quickmap()
```

Es posible que debas utilizar el `size` o `colour` de los puntos para mostrar el retraso promedio de cada aeropuerto.

16. ??Qu?? destinos tienen el promedio de retrasos m??s alto?

17. Agrega la ubicaci??n del origen y el destino (es decir, `lat` y `lon`) a `flights`.

18. ??Qu?? pas?? el 13 de junio de 2013?

19. ??Qu?? significa para un vuelo tener un `tailnum` faltante? ??Qu?? tienen en com??n los n??meros de cola que no tienen un registro coincidente en `planes`? (Sugerencia: una variable explica ~ 90% de los problemas).

20. Filtra vuelos para mostrar solo aquellos aviones que hayan volado al menos 100 vuelos.

21. Encuentra las 48 horas (en el transcurso del a??o) que tienen las peores demoras. Haz una referencia cruzada con los datos de `weather`. ??Puedes ver alg??n patr??n?

22. ??Qu?? te dice `anti_join(flights, airports, by = c("dest" = "faa"))`? ??Qu?? te dice `anti_join(airports, flights, by = c("faa" = "dest"))`?

23. Es de esperar que exista una relaci??n impl??cita entre el avi??n y la l??nea a??rea, ya que cada avi??n es volado por una sola l??nea a??rea. Confirma o rechaza esta hip??tesis usando las herramientas que aprendimos.

24. ??Cu??ntas ??rdenes diferentes hay en tu dataset?

25. ??De qu?? fechas tenemos datos? (a??o, mes y d??a m??nimo y m??ximo)?

26. ??Con qu?? granularidad est??n los datos -por d??a-, es decir, tenemos datos diarios, solo entre semana? ??Existen gaps en las fechas (d??as sin registro de ??rdenes)?

27. ??Cu??l es el delta de tiempo m??s grande entre una orden y otra -en d??as-? Utiliza `lag` en tu respuesta y `datediff` 

28. ??Cu??l es el delta de tiempo m??s peque??o entre una orden y otra -en minutos o segundos-? Utiliza `lag` en tu respuesta y `datediff`

29. ??Cu??l es el 7mo producto m??s vendido? Utiliza `rank` en tu respuesta

30. ??Cu??l es el 5to producto m??s vendido por mes? Utiliza `rank` en tu respuesta

31. ??Cu??les son jefes? Revisa el atributo `reportsto` indica su nombre `firstname`, apellido `lastname`, departamento al que pertenece `title`, desde cu??ndo est?? en la compa????a `hiredate` y cu??ntos empleados tiene a su cargo

32. Por cada "jefe" muestra el nombre `firstname` y apellido `lastname` del jefe seguido de un arreglo de id empleados `employeeid` de los empleados que tiene a su cargo. Utiliza `array_agg` en tu respuesta

33. ??Cu??l es el promedio de productos vendidos por orden y mes? 

34. ??En qu?? lugar de ventas se encuentra M??xico? (ventas a enviar a M??xico) Ocupa `rank` en tu respuesta

<!-- ### Respuestas -->

```{r, message=FALSE, warning=FALSE}

```

### Respuestas Carlos Fernando V??squez Guerra
```{r message=FALSE, warning=FALSE, paged.print=FALSE}
library(tidyverse)
library(nycflights13)
```

1. Cu??l es el aeropuerto con mayor tr??fico de entrada? (vuelos diferentes) Ocupa en tu respuesta el nombre del aeropuerto (`join`)

```{r}
flights %>%
  count(dest, sort = TRUE) %>% 
  left_join(airports,c("dest" = "faa")) %>% 
  head(1) %>% 
  select(name)
```

2. Encuentra los vuelos con un retraso mayor a una hora.

```{r}
flights %>% 
  mutate(delay_early = ((dep_delay + arr_delay)/60)) %>% 
  filter(delay_early > 1) %>% 
  arrange(desc(delay_early)) %>% 
  select(flight, delay_early)

```

3. Encuentra los vuelos en los que el retraso de llegada es m??s del doble que el retraso de salida.

```{r}
flights %>% 
  filter(arr_delay > 0 & dep_delay >0 & arr_delay > dep_delay*2) %>% 
  select(flight, arr_delay, dep_delay)
```

4. Ve la ayuda de select (`?select`) y escribe tres maneras de seleccionar las variables de retraso (delay).

```{r}
#Primera forma:
flights %>% select(ends_with("delay")) %>% head()
```
```{r}
#Segunda forma
flights %>% select(dep_delay, arr_delay) %>% head()
```






