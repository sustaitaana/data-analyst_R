---
title: "Ciencia de Datos con R"
subtitle: "3. Advanced tools for Analysis"
author: "Ana Sustaita, sustaitaana@gmail.com"
output:
  html_document:
    df_print: paged
    highlight: tango
    theme: flatly
  pdf_document: default
  word_document: default
---

![](../images/greenshark.png)

# {.tabset .tabset-fade .tabset-pills}

## stringr

`stringr` no es parte del `tidyverse`, por lo que debemos instalarlo y cargarlo explícitamente.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(stringr)
```

### Conceptos básicos

Podemos crear cadenas con comillas simples o comillas dobles. A diferencia de otros lenguajes, no hay diferencia en el comportamiento. Es recomendable usar siempre `"`, a menos que queramos crear una cadena que contenga múltiples comillas dobles.

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
string1 <- "Esto es una cadena"
string2 <- 'Si queremos incluir una "cita" dentro de una cadena, usamos comillas simples'
```

Si olvidamos cerrar una cadena, veremos `+`, el caracter de continuación:

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
# > "Esta es una cadena sin comillas de cierre
# + 
# + 
# + AYUDA, ESTOY ATORADO!
```

Si esto nos pasa, sólo debemos presionar Escape e intentar nuevamente.

Para incluir una comilla simple o doble literal en una cadena, podemos usar `\` para "escaparla":

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
double_quote <- "\"" # o '"'
single_quote <- '\'' # o "'"
```

Esto significa que si deseamos incluir una barra invertida, tendremos que duplicarla: "\\".

Debemos tener en cuenta que la representación impresa de una cadena no es la misma que la cadena por si misma, esto se debe a que la representación impresa muestra los escapes. Para ver el contenido "crudo" de la cadena, usamos `writeLines()`:

```{r, message=FALSE, warning=FALSE}
x <- c("\"", "\\")
x

writeLines(x)
```

Hay un puñado de otros caracteres especiales. Los más comunes son `"\n"`, nueva línea y `"\t"`, tab, pero podemos ver la lista completa en la ayuda de `"`: `?'"'` o `?"'"`. En ocasiones nos podemos encontrar con cadenas como `"\u00b5"` esta es una forma de escribir caracteres no alfabéticos que funcionan en todas las plataformas:

```{r, message=FALSE, warning=FALSE}
x <- "\u00b5"
x
```

Múltiples cadenas a menudo se almacenan en un vector de caracteres, que podemos crear con c():

```{r, message=FALSE, warning=FALSE}
c("one", "two", "three")
```

#### Longitud

R base contiene muchas funciones para trabajar con cadenas pero las evitaremos porque pueden ser inconsistentes, lo que las hace difíciles de recordar. En su lugar usaremos funciones de `stringr`. Estas tienen nombres más intuitivos y todos comienzan con `str_`. Por ejemplo, `str_length()` nos devuelve la cantidad de caracteres en una cadena:

```{r, message=FALSE, warning=FALSE}
str_length(c("a", "Ciencia de Datos con R", NA))
```


El prefijo común `str_` es particularmente útil si utilizamos RStudio, ya que al escribir `str_` activará la función autocompletar, lo que nos permite ver todas las funciones del `stringr`:

![](../images/stringr-autocomplete.png)

#### Combinando cadenas

Para combinar dos o más cadenas, usamos `str_c()`:

```{r, message=FALSE, warning=FALSE}
str_c("x", "y")

str_c("x", "y", "z")
```

Podemos usar el argumento `sep` para controlar la forma en que se separan las cadenas de texto:

```{r, message=FALSE, warning=FALSE}
str_c("x", "y", sep = ", ")
```

Como en la mayoría de las otras funciones en R, los valores faltantes son contagiosos. Si deseamos que se impriman como `"NA"`, usamos `str_replace_na()`:


```{r, message=FALSE, warning=FALSE}
x <- c("abc", NA)
str_c("|-", x, "-|")

str_c("|-", str_replace_na(x), "-|")
```

Como se muestra arriba, `str_c()` se vectoriza, y recicla automáticamente vectores más cortos a la misma longitud que el más largo:

```{r, message=FALSE, warning=FALSE}
str_c("prefix-", c("a", "b", "c"), "-suffix")
```

Los objetos de longitud 0 se eliminan en "silencio". Esto es particularmente útil en conjunto con `if`:


```{r, message=FALSE, warning=FALSE}
name <- "Ana"
time_of_day <- "días"
birthday <- FALSE

str_c(
  "Buenos ", time_of_day, " ", name,
  if (birthday) " y FELIZ CUMPLEAÑOS",
  "."
)
```

Para colapsar un vector de cadenas en una sola cadena, usamos `collapse`:

```{r, message=FALSE, warning=FALSE}
str_c(c("x", "y", "z"), collapse = ", ")
```


#### Subconjuntos de cadenas

Podemos extraer partes de una cadena usando `str_sub()`. Además de la cadena, `str_sub()` necesita los argumentos `start` y `end` que dan la posición (inclusiva) de la subcadena:


```{r, message=FALSE, warning=FALSE}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)

str_sub(x, -3, -1)
```

Debemos notar que `str_sub()` no fallará si la cadena es demasiado corta, solo regresará tanto como sea posible:

```{r, message=FALSE, warning=FALSE}
str_sub("a", 1, 5)
```

También podemos usar la forma de asignación de `str_sub()` para modificar cadenas:


```{r, message=FALSE, warning=FALSE}
str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))
x
```


#### Locales

Cambiar de mayúsculas a minúsculas es más complicado de lo que podría parecer a primera vista, ya que los diferentes idiomas tienen diferentes reglas para cambiar de mayúscula a minúscula. Podemos elegir qué conjunto de reglas usar al especificar una configuración regional:

```{r, message=FALSE, warning=FALSE}
# El Turco tiene dos i's: con y sin punto y tiene
# una regla diferente para pasarlas a mayúsculas:
str_to_upper(c("i", "ı"))

str_to_upper(c("i", "ı"), locale = "tr")
```


La configuración regional se especifica como un código de idioma ISO 639, que es una abreviación de dos o tres letras. Podemos consultar la lista de [Wikipedia](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) para conocer el código de distintos idiomas, incluído el nuestro. Si dejamos la configuración regional en blanco, usará la configuración regional actual, tal como lo proporciona nuestro sistema operativo.

Otra operación importante que se ve afectada por la configuración regional es el ordenamiento. Las funciones de R base `order()` y `sort()` ordenan cadenas usando la configuración regional actual. Si deseamos un comportamiento robusto en diferentes computadoras, es posible que debamos utilizar `str_sort()` y `str_order()` que toman un argumento adicional `locale`:

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "eggplant", "banana")
str_sort(x, locale = "en")  # Inglés

str_sort(x, locale = "haw") # Hawaiano
```


### Patrones con expresiones regulares

Regexps es un lenguaje muy conciso que nos permite describir patrones en cadenas.

Para aprender expresiones regulares, usaremos `str_view()` y `str_view_all()`. Estas funciones toman un vector de caracteres y una expresión regular y muestran cómo coinciden. Comenzaremos con expresiones regulares muy simples y luego gradualmente lo complicaremos. Una vez que dominemos la coincidencia de patrones, aprenderemos cómo aplicar esas ideas con varias funciones de cadenas.

#### Patrones básicos

Los patrones más simples coinciden con cadenas exactas:

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "banana", "pear")
str_view(x, "an")
```

El siguiente paso en la complejidad es `.`, que coincide con cualquier caracter (excepto una nueva línea):

```{r, message=FALSE, warning=FALSE}
str_view(x, ".a.")
```

Pero si "`.`" coincide con cualquier caracter, ¿cómo encontramos el caracter "`.`"? Debemos usar un "escape" para decirle a la expresión regular que deseamos coincidirlo exactamente en vez de usar su comportamiento especial. Al igual que las cadenas, las expresiones regulares usan la barra invertida, `\`, para escapar del comportamiento especial. Entonces, para que coincida con un `.`, necesitamos la expresión regular `\.`. Lamentablemente, esto crea un problema. Usamos cadenas para representar expresiones regulares, y `\` también se usa como un símbolo de escape en cadenas. Entonces para crear la expresión regular `\.` necesitamos la cadena `"\\."`.

```{r, message=FALSE, warning=FALSE}
# Para crear la expresión regular, necesitamos \\
dot <- "\\."

# Pero la expresión sólo contiene un backslash:
writeLines(dot)

# Con esto, le decimos a R que busque un . explícito
str_view(c("abc", "a.c", "bef"), "a\\.c")
```


Si `\` se usa como un carácter de escape en expresiones regulares, ¿cómo se combina un literal `\`? Necesitamos escapar, creando la expresión regular `\\`. Para crear esa expresión regular, necesitamos usar una cadena, que también necesita escapar `\`. Eso significa que para hacer coincidir un literal `\` necesitamos escribir `"\\\\"` ¡necesitamos cuatro barras invertidas para que coincida con una!

```{r, message=FALSE, warning=FALSE}
x <- "a\\b"
writeLines(x)

str_view(x, "\\\\")
```

A partir de ahora, escribiremos la expresión regular como `\.` y las cadenas que representan la expresión regular como `"\\."`.


#### Anclajes

Por defecto, las expresiones regulares coincidirán con cualquier parte de una cadena. A menudo es útil anclar la expresión regular para que coincida desde el principio o el final de la cadena. Podemos usar:

+ `^` para que coincida con el comienzo de la cadena.

+ `$` para que coincida el final de la cadena.

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "banana", "pear")
str_view(x, "^a")

str_view(x, "a$")
```

Para recordar cuál es cuál, prueba esta mnemotecnia de [Evan Misshula](https://twitter.com/emisshula/status/323863393167613953): si comienzas con potencia (`^`), terminas con dinero (`$`).

Para forzar una expresión regular a que sólo coincida con una cadena completa, debemos anclarla con ambos `^` y `$`:

```{r, message=FALSE, warning=FALSE}
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")

str_view(x, "^apple$")
```

También podemos coincidir el límite entre las palabras con `\b`.

#### Clases de caracteres y alternativas

Hay una serie de patrones especiales que coinciden con más de un caracter. Ya vimos `.`, que coincide con cualquier caracter que no sea una nueva línea. Hay otras cuatro herramientas útiles:

+ `\d`: coincide con cualquier dígito.

+ `\s`: coincide con cualquier espacio en blanco.

+ `[abc]`: coincide con a, b, o c.

+ `[^abc]`: coincide con cualquier cosa excepto a, b, o c.

Recordemos que para crear una expresión regular que contenga `\d` o `\s`, debemos escapar `\` de la cadena, por lo que escribiremos `"\\d"` o `"\\s"`.

Una clase de caracteres que contenga un solo carácter es una buena alternativa a los escapes de barra invertida cuando se desea incluir un metacarácter único en una expresión regular. Muchas personas lo encuentran más legible.

```{r, message=FALSE, warning=FALSE}
# Buscar un caracter que normalmente tiene un significado especial en regex
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")

str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")

str_view(c("abc", "a.c", "a*c", "a c"), "a[ ]")
```


Esto funciona para la mayoría (pero no todos) de los metacaracteres de expresiones regulares: `$` `.` `|` `?` `*` `+` `(` `)` `[` `{`. Desafortunadamente, algunos caracteres tienen un significado especial incluso dentro de una clase de caracteres y deben manejarse con escapes de barra invertida: `]` `\` `^` y `-`.

Podemos usar la alternancia para elegir uno o más patrones alternativos. Por ejemplo, `abc|d..f` coincidirá con `"abc"` o `"deaf"`. Notemos que la precedencia para `|` es baja, por lo que `abc|xyz` coincide `abc` o `xyz` no `abcyz` o `abxyz`. Al igual que con las expresiones matemáticas, si la precedencia se vuelve confusa, usamos paréntesis para dejar en claro lo que deseamos:

```{r, message=FALSE, warning=FALSE}
str_view(c("grey", "gray"), "gr(e|a)y")
```

#### Repetición

El siguiente paso en complejidad implica controlar cuántas veces coincide un patrón:

+ `?`: 0 o 1

+ `+`: 1 o más

+ `*`: 0 o más

```{r, message=FALSE, warning=FALSE}
x <- "1888 es el año más largo en números romanos: MDCCCLXXXVIII"
str_view(x, "CC?")

str_view(x, "CC+")

str_view(x, 'C[LX]+')
```

Notemos que la precedencia de estos operadores es alta, por lo que podemos escribir: `colou?r` para que coincida con la ortografía estadounidense o británica, por ejemplo. Eso significa que la mayoría de los usos necesitarán paréntesis, como `bana(na)+`.

También podemos especificar el número de coincidencias con precisión:

+ `{n}`: exactamente n
+ `{n,}`: n o más
+ `{,m}`: a lo sumo m
+ `{n,m}`: entre n y m

```{r, message=FALSE, warning=FALSE}
str_view(x, "C{2}")

str_view(x, "C{2,}")

str_view(x, "C{2,3}")
```

Por defecto, estas coincidencias son "codiciosas": coincidirán con la cadena más larga posible. Podemos hacerlas "flojas", haciendo coincidir la cadena más corta posible poniendo un `?` después de ellas. Esta es una característica avanzada de las expresiones regulares, pero es útil saber que existe:

```{r, message=FALSE, warning=FALSE}
str_view(x, 'C{2,3}?')

str_view(x, 'C[LX]+?')
```

#### Agrupación y referencias

Anteriormente, aprendimos que los paréntesis son una forma de desambiguar expresiones complejas. Los paréntesis también crean un grupo de captura *numerado* (número 1, 2, etc.). Un grupo de captura almacena *la parte de la cadena* que coincide con la parte de la expresión regular dentro de los paréntesis. Podemos consultar textos anteriores con un grupo de captura con *referencias*, como `\1`, `\2`, etc. Por ejemplo, la siguiente expresión regular encuentra todas las frutas que tienen un par de letras repetidas.

```{r, message=FALSE, warning=FALSE}
str_view(fruit, "(..)\\1", match = TRUE)
```

(Pronto, veremos cómo son útiles junto con `str_match()`.)

### Herramientas

Ahora que conocemos los conceptos básicos de las expresiones regulares, es hora de aprender cómo aplicarlas a problemas reales. Aprenderemos funciones de `stringr` que nos permiten:

+ Determinar qué cadenas coinciden con un patrón.
+ Encontrar las posiciones de las coincidencias.
+ Extraer el contenido de las coincidencias.
+ Reemplazar coincidencias con nuevos valores.
+ Dividir una cadena basado en una coincidencia.

#### Detectar coincidencias

Para determinar si un vector de caracteres coincide con un patrón, usamos `str_detect()`. Devuelve un vector lógico con la misma longitud que la entrada:

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "banana", "pear")
str_detect(x, "e")
```


Recordemos que cuando se utiliza un vector lógico en un contexto numérico, `FALSE` se convierte en 0 y `TRUE` se convierte en 1. Esto hace que `sum()` y `mean()` sean utiles si deseamos responder preguntas sobre coincidencias en un vector más grande:

```{r, message=FALSE, warning=FALSE}
# ¿Cuántas palabras empiezan con t?
sum(str_detect(words, "^t"))

# ¿Qué proporción de palabras terminan en vocal?
mean(str_detect(words, "[aeiou]$"))
```

Cuando tenemos condiciones lógicas complejas (por ejemplo, coincidir con `a` o `b`, pero no con `c` a menos que `d`) a menudo es más fácil combinar múltiples llamadas de `str_detect()` con operadores lógicos, en lugar de tratar de crear una única expresión regular. Por ejemplo, aquí hay dos formas de encontrar todas las palabras que no contienen vocales:

```{r, message=FALSE, warning=FALSE}
# Encuentra todas las palabras que contengan al menos una vocal, y niegalas
no_vowels_1 <- !str_detect(words, "[aeiou]")

# Encuentra todas las palabras que estén compuestas por puras consonantes
no_vowels_2 <- str_detect(words, "^[^aeiou]+$")
identical(no_vowels_1, no_vowels_2)
```


Los resultados son idénticos, pero el primer enfoque es significativamente más fácil de entender. Si una expresión regular se vuelve demasiado complicada, debemos intentar dividirla en partes más pequeñas, dándole un nombre a cada pieza y luego combinando las piezas con operaciones lógicas.

Un uso común de `str_detect()` es seleccionar los elementos que coinciden con un patrón. Podemos hacer esto con un subconjunto lógico o el `str_subset()` conveniente :


```{r, message=FALSE, warning=FALSE}
words[str_detect(words, "x$")]

str_subset(words, "x$")
```


Normalmente, sin embargo, las cadenas serán una columna de un data frame, y en su lugar preferiremos usar `filter`:


```{r, message=FALSE, warning=FALSE}
df <- tibble(
  word = words, 
  i = seq_along(word)
)
df %>% 
  filter(str_detect(words, "x$"))
```


Una variación de `str_detect()` es `str_count()`: en lugar de un simple sí o no, nos dice cuántas coincidencias hay en una cadena:

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "banana", "pear")
str_count(x, "a")

# En promedio, ¿cuántas vocales por palabra?
mean(str_count(words, "[aeiou]"))
```

Es natural usar `str_count()` con `mutate()`:

```{r, message=FALSE, warning=FALSE}
df %>% 
  mutate(
    vowels = str_count(word, "[aeiou]"),
    consonants = str_count(word, "[^aeiou]")
  )
```

Debemos tener en cuenta que las coincidencias nunca se superponen. Por ejemplo, en `"abababa"`, ¿cuántas veces coincidirá el patrón `"aba"`? Las expresiones regulares dicen dos, no tres:

```{r, message=FALSE, warning=FALSE}
str_count("abababa", "aba")

str_view_all("abababa", "aba")
```


Muchas funciones de `stringr` vienen en pares: una función funciona con una sola coincidencia, y la otra funciona con todas las coincidencias. La segunda función tendrá el sufijo `_all`.


#### Extraer coincidencias

Para extraer el texto real de una coincidencia, usamos `str_extract()`. Para demostrarlo, vamos a necesitar un ejemplo más complicado. Usaremos las [Oraciones de Harvard](https://en.wikipedia.org/wiki/Harvard_sentences), que fueron diseñadas para probar sistemas VOIP, pero también son útiles para practicar expresiones regulares. Estas se encuentran en `stringr::sentences`:

```{r, message=FALSE, warning=FALSE}
length(sentences)

head(sentences)
```

Imagina que queremos encontrar todas las oraciones que contienen un color. Primero creamos un vector de nombres de colores y luego lo convertimos en una única expresión regular:

```{r, message=FALSE, warning=FALSE}
colours <- c("red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match
```


Ahora podemos seleccionar las oraciones que contienen un color, y luego extraer el color para descubrir cuál es:

```{r, message=FALSE, warning=FALSE}
has_colour <- str_subset(sentences, colour_match)
matches <- str_extract(has_colour, colour_match)
head(matches)
```

Notemos que `str_extract()` solo extrae la primera coincidencia. Podemos ver eso más fácilmente al seleccionar primero todas las oraciones que tienen más de 1 coincidencia:

```{r, message=FALSE, warning=FALSE}
more <- sentences[str_count(sentences, colour_match) > 1]
str_view_all(more, colour_match)

str_extract(more, colour_match)
```

Este es un patrón común para las funciones de cadenas, porque trabajar con una sola coincidencia nos permite utilizar estructuras de datos mucho más simples. Para obtener todas las coincidencias, usa `str_extract_all()`. Devuelve una lista:

```{r, message=FALSE, warning=FALSE}
str_extract_all(more, colour_match)
```

Si usamos `simplify = TRUE`, `str_extract_all()` devolverá una matriz con coincidencias cortas expandidas a la misma longitud que la más larga:

```{r, message=FALSE, warning=FALSE}
str_extract_all(more, colour_match, simplify = TRUE)

x <- c("a", "a b", "a b c")
str_extract_all(x, "[a-z]", simplify = TRUE)
```

##### Ejercicios

1. En el ejemplo anterior, es posible que hayas notado que la expresión regular coincide con "flickered", que no es un color. Modifica la expresión regular para solucionar el problema.

```{r, message=FALSE, warning=FALSE}
colours <- c("\\bred\\b", "\\borange\\b", "\\byellow\\b", "\\bgreen\\b", "\\bblue\\b", "\\bpurple\\b")
colour_match <- str_c(colours, collapse = "|")
colour_match
```

2. De los datos de las oraciones de Harvard, extrae:

    + La primera palabra de cada oración
    + Todas las palabras que terminan en `ing`.
    + Todos los plurales
    
    
#### Coincidencias agrupadas

Ya sabemos que podemos hacer uso de el paréntesis para aclarar la precedencia y para referencias al momento de la comparación. También podemos usarlo para extraer partes de una coincidencia compleja. Por ejemplo, imagina que queremos extraer sustantivos de las oraciones. Como heurística, buscaremos cualquier palabra que venga después de `"a"` o `"the"`. Definir una "palabra" en una expresión regular es un poco complicado, así que utilizaremos una aproximación simple: una secuencia de al menos un carácter que no es un espacio.

```{r, message=FALSE, warning=FALSE}
noun <- "(a|the) ([^ ]+)"

has_noun <- sentences %>%
  str_subset(noun) %>%
  head(10)
has_noun %>% 
  str_extract(noun)
```

`str_extract()` nos da la coincidencia completa, `str_match()` nos da a cada componente individual. En lugar de un vector de caracteres, devuelve una matriz, con una columna para la coincidencia completa seguida de una columna para cada grupo:

```{r, message=FALSE, warning=FALSE}
has_noun %>% 
  str_match(noun)
```

(Como era de esperar, nuestra heurística para detectar sustantivos es pobre, y también capta adjetivos como `smooth` y `parked`).

Si tenemos los datos en un `tibble`, a menudo es más fácil de usar `tidyr::extract()`. Funciona de la misma manera `str_match()` pero requiere que nombremos las coincidencias, que luego se colocan en columnas nuevas:

```{r, message=FALSE, warning=FALSE}
tibble(sentence = sentences) %>% 
  tidyr::extract(
    sentence, c("article", "noun"), "(a|the) ([^ ]+)", 
    remove = FALSE
  )
```

Como en `str_extract()`, si queremos todas las coincidencias para cada cadena, necesitaremos `str_match_all()`.


##### Ejercicios

1. Encuentra todas las palabras que vienen después de un "número" como "uno", "dos", "tres", etc. Saca el número y la palabra (en inglés).

2. Encuentra todas las contracciones. Separa las piezas antes y después del apóstrofe.


#### Reemplazar coincidencias

`str_replace()` y `str_replace_all()` nos permiten reemplazar coincidencias con nuevas cadenas. El uso más simple es reemplazar un patrón con una cadena fija:

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "pear", "banana")
str_replace(x, "[aeiou]", "-")

str_replace_all(x, "[aeiou]", "-")
```


Con `str_replace_all()` podemos realizar reemplazos múltiples mediante el suministro de un vector nombrado:

```{r, message=FALSE, warning=FALSE}
x <- c("1 house", "2 cars", "3 people")
str_replace_all(x, c("1" = "one", "2" = "two", "3" = "three"))
```


En lugar de reemplazar con una cadena fija, podemos usar referencias para insertar componentes de la coincidencia. Cambiemos la segunda por la tercera palabra:

```{r, message=FALSE, warning=FALSE}
sentences %>% 
  str_replace("([^ ]+) ([^ ]+) ([^ ]+)", "\\1 \\3 \\2") %>% 
  head(5)
```


##### Ejercicios

1. Reemplaza todas las barras diagonales en una cadena con barras diagonales inversas.
```{r, message=FALSE, warning=FALSE}
palabra <- "2018/25/09/"
writeLines(palabra)
 palabra%>% 
  str_replace_all("\\/", "\\\\")
```

2. Implementa una versión simple de `str_to_lower()` usando `replace_all()`.

3. Cambia la primera y la última letra en `words`. ¿Cuáles de esas cadenas son todavía palabras?

#### División

Usamos `str_split()` para dividir una cadena en pedazos. Por ejemplo, podríamos dividir oraciones en palabras:

```{r, message=FALSE, warning=FALSE}
sentences %>%
  head(5) %>% 
  str_split(" ")
```


Debido a que cada componente puede contener un número diferente de elementos, esto devuelve una lista. Si estamos trabajando con un vector de longitud 1, lo más fácil es extraer el primer elemento de la lista:

```{r, message=FALSE, warning=FALSE}
"a|b|c|d" %>% 
  str_split("\\|") %>% 
  .[[1]]
```


De lo contrario, al igual que las otras funciones de cadena que devuelven una lista, podemos usar `simplify = TRUE` para obtener una matriz:

```{r, message=FALSE, warning=FALSE}
sentences %>%
  head(5) %>% 
  str_split(" ", simplify = TRUE)
```

También podemos pedir un número máximo de elementos:

```{r, message=FALSE, warning=FALSE}
fields <- c("Nombre: Ana", "País: México", "Edad: 29")
fields %>% str_split(": ", n = 2, simplify = TRUE)
```


En lugar de dividir cadenas por patrones, podemos dividir por carácter, línea, oración y palabra usando `boundary()`:

```{r, message=FALSE, warning=FALSE}
x <- "Esta es una oración. Esta es otra oración."
str_view_all(x, boundary("word"))

str_split(x, " ")[[1]]

str_split(x, boundary("word"))[[1]]
```

##### Ejercicios

1. Divide una cadena como "apples, pears, and bananas" en componentes individuales.

2. ¿Por qué es mejor dividir con `boundary("word")` que con `" "`?

3. ¿Qué hace la división con una cadena vacía (`""`)? Experimenta y luego lee la documentación.

#### Buscar coincidencias

`str_locate()` y `str_locate_all()` nos darán las posiciones inicial y final de cada coincidencia. Estos son particularmente útiles cuando ninguna de las otras funciones hace exactamente lo que deseamos. Podemos usar `str_locate()` para encontrar el patrón coincidente, `str_sub()` para extraerlo y/o modificarlo.

### Otros tipos de patrones

Cuando utilizamos un patrón que es una cadena, se envuelve automáticamente en una llamada a `regex()`:

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
# La llamada regular:
str_view(fruit, "nana")
# Es una versión corta de:
str_view(fruit, regex("nana"))
```


Podemos usar los otros argumentos de `regex()` para controlar los detalles de la coincidencia:

+ `ignore_case = TRUE` permite que los caracteres coincidan con sus mayúsculas o minúsculas. Esto siempre usa la configuración regional actual.

```{r, message=FALSE, warning=FALSE}
bananas <- c("banana", "Banana", "BANANA")
str_view(bananas, "banana")

str_view(bananas, regex("banana", ignore_case = TRUE))
```


+ `multiline = TRUE` permite a `^` y `$` coincidir el inicio y el final de cada línea en lugar del inicio y el final de la cadena completa.

```{r, message=FALSE, warning=FALSE}
x <- "Line 1\nLine 2\nLine 3"
str_extract_all(x, "^Line")[[1]]

str_extract_all(x, regex("^Line", multiline = TRUE))[[1]]
```


+ `comments = TRUE` nos permite usar comentarios y espacios en blanco para hacer que las expresiones regulares complejas sean más comprensibles. Los espacios son ignorados, como lo es todo después `#`. Para que coincida con un espacio literal, necesitamos escaparlo: `"\\ "`.


```{r, message=FALSE, warning=FALSE}
phone <- regex("
  \\(?     # optional opening parens
  (\\d{3}) # area code
  [) -]?   # optional closing parens, space, or dash
  (\\d{3}) # another three numbers
  [ -]?    # optional space or dash
  (\\d{3}) # three more numbers
  ", comments = TRUE)

str_match("514-791-8141", phone)
```


+ `dotall = TRUE` permite que `.` coincida con todo, incluso `\n`.

Hay otras tres funciones que podemos usar en lugar de `regex()`:

+ `fixed()`: coincide exactamente con la secuencia de bytes especificada. Ignora todas las expresiones regulares especiales y opera a un nivel muy bajo. Esto nos permite evitar el escape complejo y puede ser mucho más rápido que las expresiones regulares. El siguiente microbenchmark muestra que es aproximadamente 3 veces más rápido en un ejemplo simple.

```{r, message=FALSE, warning=FALSE}
library(microbenchmark)
microbenchmark::microbenchmark(
  fixed = str_detect(sentences, fixed("the")),
  regex = str_detect(sentences, "the"),
  times = 20
)
```


Debemos tener cuidado al usar `fixed()` con datos que no sean en inglés. Es problemático porque a menudo hay múltiples formas de representar al mismo caracter. Por ejemplo, hay dos formas de definir `"á"`: como un solo caracter o como una `"a"` más un acento:

```{r, message=FALSE, warning=FALSE}
a1 <- "\u00e1"
a2 <- "a\u0301"
c(a1, a2)

a1 == a2
```

Se representan de forma idéntica, pero debido a que están definidos de manera diferente, `fixed()` no encuentran una coincidencia. En cambio, podemos usar `coll()`, definido a continuación, para respetar las reglas de comparación de caracteres humanos:

```{r, message=FALSE, warning=FALSE}
str_detect(a1, fixed(a2))

str_detect(a1, coll(a2))
```


+ `coll()`: compara cadenas usando las reglas de colación estándar. Esto es útil para hacer coincidencias insensibles a mayúscuas y minúsculas. Notemos que `coll()` toma un parámetro `locale` que controla qué reglas se usan para comparar caracteres. Desafortunadamente, ¡diferentes partes del mundo usan diferentes reglas!

```{r, message=FALSE, warning=FALSE}
# Esto significa que debemos estar conscientes de las diferencias cuando hagamos coincidencias con sensibilidad de mayúsculas:
i <- c("I", "İ", "i", "ı")
i

str_subset(i, coll("i", ignore_case = TRUE))

str_subset(i, coll("i", ignore_case = TRUE, locale = "tr"))
```

Tanto `fixed()` como `regex()` tienen argumentos `ignore_case`, pero no permiten que podamos elegir la configuración regional: siempre utilizan la configuración regional predeterminada. Podemos verla así:

```{r, message=FALSE, warning=FALSE}
stringi::stri_locale_info()
```

La desventaja de `coll()` es la velocidad porque las reglas para reconocer qué caracteres son los mismos son complicadas, `coll()` es relativamente lento en comparación con `regex()` y `fixed()`.

+ Como vimos con `str_split()` podemos usar `boundary()` para unir límites. También podemos usarlo con las otras funciones:

```{r, message=FALSE, warning=FALSE}
x <- "Esta es una oración."
str_view_all(x, boundary("word"))

str_extract_all(x, boundary("word"))
```


#### Ejercicio

1. ¿Cuáles son las cinco palabras más comunes en `sentences`?

### Otros usos de expresiones regulares

Hay dos funciones útiles en R base que también usan expresiones regulares:

+ `apropos()` busca todos los objetos disponibles del entorno global. Esto es útil si no recordamos el nombre de alguna función.

```{r, message=FALSE, warning=FALSE}
apropos("replace")
```


+ `dir()` lista todos los archivos en un directorio. El argumento `pattern` toma una expresión regular y solo devuelve nombres de archivos que coinciden con el patrón. Por ejemplo, podemos encontrar todos los archivos R Markdown en el directorio actual con:

```{r, message=FALSE, warning=FALSE}
head(dir(pattern = "\\.Rmd$"))
```

(Si te sientes más cómodo con "globs" como `*.Rmd`, puedes convertirlos a expresiones regulares con `glob2rx()`):

### stringi

`stringr` está construido sobre el paquete `stringi`. `stringr` es útil cuando estamos aprendiendo porque expone un conjunto mínimo de funciones, que se han seleccionado cuidadosamente para manejar las funciones de manipulación de cadenas más comunes. `stringi`, por otro lado, está diseñado para ser completo. Contiene casi todas las funciones que podamos necesitar: `stringi` tiene 234 funciones contra las 46 de `stringr`.

Si te encuentras luchando por hacer algo en `stringr`, vale la pena echarle un vistazo a `stringi`. Los paquetes funcionan de manera muy similar, por lo que deberías poder traducir el conocimiento de forma natural. La principal diferencia es el prefijo: `str_` vs `stri_`.

#### Ejercicios

1. Encuentra las funciones de stringi que:
    
    + Cuenta el número de palabras.
    + Encuentra cadenas duplicadas.
    + Genera texto aleatorio.
    
2. ¿Cómo controlas el lenguaje que `stri_sort()` usa para ordenar?

## forcats

En R, los factores se usan para trabajar con variables categóricas, variables que tienen un conjunto fijo y conocido de valores posibles. También son útiles cuando queremos mostrar vectores de caracteres en un orden no alfabético.

Históricamente, los factores eran mucho más fáciles de trabajar que los caracteres. Como resultado, muchas de las funciones de R base automáticamente convierten los caracteres en factores. Esto significa que los factores a menudo surgen en lugares donde no son realmente útiles.

Para trabajar con factores, usaremos el paquete `forcats`, que proporciona herramientas para trabajar con variables categóricas. Proporciona una amplia gama de ayudantes para trabajar con factores. `forcats` no es parte del tidyverse central, por lo que debemos cargarlo explícitamente.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(forcats)
```


### Creando factores

Imaginemos que tenemos una variable que registra el mes:

```{r, message=FALSE, warning=FALSE}
x1 <- c("Dec", "Apr", "Jan", "Mar")
```


Usar una cadena para registrar esta variable tiene dos problemas:

1. Solo hay doce meses posibles y no hay nada que nos salve de los errores tipográficos:

```{r, message=FALSE, warning=FALSE}
x2 <- c("Dec", "Apr", "Jam", "Mar")
```


2. No ordena de una manera útil:

```{r, message=FALSE, warning=FALSE}
sort(x1)
```

Podemos solucionar ambos problemas con un factor. Para crear un factor, debemos comenzar creando una lista de los niveles válidos:

```{r, message=FALSE, warning=FALSE}
month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
```

Ahora podemos crear un factor:

```{r, message=FALSE, warning=FALSE}
y1 <- factor(x1, levels = month_levels)
y1

sort(y1)
```

Y cualquier valor que no esté en el conjunto se convertirá silenciosamente a `NA`:

```{r, message=FALSE, warning=FALSE}
y2 <- factor(x2, levels = month_levels)
y2
```

Si omitimos los niveles, se tomarán de los datos en orden alfabético:

```{r, message=FALSE, warning=FALSE}
factor(x1)
```

A veces preferiremos que el orden de los niveles coincida con el orden de la primera aparición en los datos. Podemos hacerlo al crear el factor estableciendo niveles a `unique(x)`, o después del factor, con `fct_inorder()`:

```{r, message=FALSE, warning=FALSE}
f1 <- factor(x1, levels = unique(x1))
f1

f2 <- x1 %>% factor() %>% fct_inorder()
f2
```


Si alguna vez necesitamos acceder al conjunto de niveles válidos directamente, podemos hacerlo con `levels()`:

```{r, message=FALSE, warning=FALSE}
levels(f2)
```

### Encuesta social general

Usaremos `forcats::gss_cat`. Es una muestra de datos de la [Encuesta Social General](http://gss.norc.org/), que es una encuesta realizada en Estados unidos por la organización de investigación independiente **NORC** de la **Universidad de Chicago**. La encuesta tiene miles de preguntas, en `gss_cat` se encuentran algunas que ilustrarán algunos desafíos comunes que encontramos al trabajar con factores.

```{r, message=FALSE, warning=FALSE}
gss_cat
```

Cuando los factores se almacenan en un `tibble`, no podemos ver sus niveles tan fácilmente. Una forma de verlos es con `count()`:

```{r, message=FALSE, warning=FALSE}
gss_cat %>%
  count(race)
```

O con una gráfica de barras:

```{r, message=FALSE, warning=FALSE}
ggplot(gss_cat, aes(race)) +
  geom_bar()
```

Por defecto, `ggplot2` soltará niveles que no tienen ningún valor. Podemos obligarlo a mostrarlos con:

```{r, message=FALSE, warning=FALSE}
ggplot(gss_cat, aes(race)) +
  geom_bar() +
  scale_x_discrete(drop = FALSE)
```

Estos niveles representan valores válidos que simplemente no ocurrieron en este conjunto de datos.

Al trabajar con factores, las dos operaciones más comunes cambian el orden de los niveles y cambian los valores de los niveles.

#### Ejercicios

1. Explora la distribución de `rincome` (ingreso reportado). ¿Qué hace que la gráfica de barras predeterminado sea difícil de entender? ¿Cómo podrías mejorarla?

2. ¿Cuál es el más común `relig` en esta encuesta? ¿Cuál es el más común `partyid`?

### Modificación de orden de los factores

A menudo es útil cambiar el orden de los niveles de los factores en una visualización. Por ejemplo, imagina que queremos explorar el promedio de horas dedicadas a ver televisión por día en diferentes religiones:

```{r, message=FALSE, warning=FALSE}
relig_summary <- gss_cat %>%
  group_by(relig) %>%
  summarise(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(relig_summary, aes(tvhours, relig)) + geom_point()
```

Es difícil interpretar esta gráfica porque no hay un patrón general. Podemos mejorarlo reordenando los niveles de `relig` usando `fct_reorder()`. `fct_reorder()` toma tres argumentos:

+ `f`, el factor cuyos niveles queremos modificar
+ `x`, un vector numérico que deseamos usar para reordenar los niveles.
+ Opcionalmente, `fun` una función que se usa si hay múltiples valores de `x` para cada valor de `f`. El valor predeterminado es `median`.

```{r, message=FALSE, warning=FALSE}
ggplot(relig_summary, aes(tvhours, fct_reorder(relig, tvhours))) +
  geom_point()
```

Reordenar la religión hace que sea mucho más fácil ver que las personas de la categoría "No sé" ven mucha más televisión, y el Hinduismo y otras religiones orientales ven mucho menos.

A medida que comenzamos a hacer transformaciones más complicadas, es recomendable moverlas de `aes()` a un `mutate()` por separado. Por ejemplo, podríamos reescribir la gráfica anterior como:

```{r, message=FALSE, warning=FALSE}
relig_summary %>%
  mutate(relig = fct_reorder(relig, tvhours)) %>%
  ggplot(aes(tvhours, relig)) +
    geom_point()
```

¿Qué pasa si creamos una gráfica similar mirando cómo varía la edad promedio a través del nivel de ingresos reportados?

```{r, message=FALSE, warning=FALSE}
rincome_summary <- gss_cat %>%
  group_by(rincome) %>%
  summarise(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(rincome_summary, aes(age, fct_reorder(rincome, age))) + geom_point()
```

¡Aquí, reordenar arbitrariamente los niveles no es una buena idea! Eso es porque `rincome` ya tiene un orden principal con el que no deberíamos meternos. Reservemos `fct_reorder()` para factores cuyos niveles se ordenan arbitrariamente.

Sin embargo, tiene sentido tirar "No aplicable" al frente con los otros niveles especiales. Podemos usar `fct_relevel()`. Toma un factor, `f` y luego cualquier cantidad de niveles que deseemos mover al frente de la línea.

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
ggplot(rincome_summary, 
       aes(age, fct_relevel(rincome, "Not applicable")))
+ geom_point()
```

![](../images/graph1.png)

¿Por qué crees que la edad promedio para "No aplicable" es tan alta?

Otro tipo de reordenamiento es útil cuando se colorean las líneas en un diagrama. `fct_reorder2()` reordena el factor por los valores `y` asociados con los valores `x` más grandes. Esto hace que la gráfica sea más fácil de leer porque los colores de la línea se alinean con la leyenda.

```{r, message=FALSE, warning=FALSE}
by_age <- gss_cat %>%
  filter(!is.na(age)) %>%
  count(age, marital) %>%
  group_by(age) %>%
  mutate(prop = n / sum(n))

ggplot(by_age, aes(age, prop, colour = marital)) +
  geom_line(na.rm = TRUE)

ggplot(by_age, 
       aes(age, prop, colour = fct_reorder2(marital, age, prop))) +
  geom_line() +
  labs(colour = "marital")
```

Finalmente, para gráficas de barra, podemos usar `fct_infreq()` para ordenar niveles en frecuencia creciente: este es el tipo más simple de reordenamiento porque no necesita ninguna variable adicional. Es posible que necesitemos combinar con `fct_rev()`.

```{r, message=FALSE, warning=FALSE}
gss_cat %>%
  mutate(marital = marital %>% fct_infreq() %>% fct_rev()) %>%
  ggplot(aes(marital)) +
    geom_bar()
```


15.4.1 Ejercicios
Hay algunos números sospechosamente altos en tvhours. ¿Es el medio un buen resumen?

Para cada factor, gss_catidentifique si el orden de los niveles es arbitrario o de principios.

¿Por qué mover "No aplicable" al frente de los niveles lo mueve al final de la gráfica?

15.5 Modificación de niveles de factores
Más poderoso que cambiar las órdenes de los niveles es cambiar sus valores. Esto le permite aclarar las etiquetas para su publicación y los niveles de contracción para las pantallas de alto nivel. La herramienta más general y poderosa es fct_recode(). Le permite recodificar o cambiar el valor de cada nivel. Por ejemplo, tome el gss_cat$partyid:

gss_cat %>% count(partyid)
#> # A tibble: 10 x 2
#>   partyid                n
#>   <fct>              <int>
#> 1 No answer            154
#> 2 Don't know             1
#> 3 Other party          393
#> 4 Strong republican   2314
#> 5 Not str republican  3032
#> 6 Ind,near rep        1791
#> # ... with 4 more rows
Los niveles son escuetos e inconsistentes. Vamos a ajustarlos para que sean más largos y usar una construcción paralela.

gss_cat %>%
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat"
  )) %>%
  count(partyid)
#> # A tibble: 10 x 2
#>   partyid                   n
#>   <fct>                 <int>
#> 1 No answer               154
#> 2 Don't know                1
#> 3 Other party             393
#> 4 Republican, strong     2314
#> 5 Republican, weak       3032
#> 6 Independent, near rep  1791
#> # ... with 4 more rows
fct_recode() dejará los niveles que no se mencionan explícitamente tal como están, y le advertirá si se refiere accidentalmente a un nivel que no existe.

Para combinar grupos, puede asignar múltiples niveles antiguos al mismo nivel nuevo:

gss_cat %>%
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat",
    "Other"                 = "No answer",
    "Other"                 = "Don't know",
    "Other"                 = "Other party"
  )) %>%
  count(partyid)
#> # A tibble: 8 x 2
#>   partyid                   n
#>   <fct>                 <int>
#> 1 Other                   548
#> 2 Republican, strong     2314
#> 3 Republican, weak       3032
#> 4 Independent, near rep  1791
#> 5 Independent            4119
#> 6 Independent, near dem  2499
#> # ... with 2 more rows
Debe usar esta técnica con cuidado: si agrupa categorías que son realmente diferentes, terminará con resultados engañosos.

Si quiere colapsar muchos niveles, fct_collapse()es una variante útil de fct_recode(). Para cada nueva variable, puede proporcionar un vector de niveles antiguos:

gss_cat %>%
  mutate(partyid = fct_collapse(partyid,
    other = c("No answer", "Don't know", "Other party"),
    rep = c("Strong republican", "Not str republican"),
    ind = c("Ind,near rep", "Independent", "Ind,near dem"),
    dem = c("Not str democrat", "Strong democrat")
  )) %>%
  count(partyid)
#> # A tibble: 4 x 2
#>   partyid     n
#>   <fct>   <int>
#> 1 other     548
#> 2 rep      5346
#> 3 ind      8409
#> 4 dem      7180
A veces solo quieres agrupar a todos los grupos pequeños para simplificar un diagrama o una tabla. Ese es el trabajo de fct_lump():

gss_cat %>%
  mutate(relig = fct_lump(relig)) %>%
  count(relig)
#> # A tibble: 2 x 2
#>   relig          n
#>   <fct>      <int>
#> 1 Protestant 10846
#> 2 Other      10637
El comportamiento predeterminado es agrupar progresivamente los grupos más pequeños, asegurando que el agregado sigue siendo el grupo más pequeño. En este caso, no es muy útil: es cierto que la mayoría de los estadounidenses en esta encuesta son protestantes, pero es probable que hayamos colapsado.

En cambio, podemos usar el nparámetro para especificar cuántos grupos (excluyendo otros) queremos mantener:

gss_cat %>%
  mutate(relig = fct_lump(relig, n = 10)) %>%
  count(relig, sort = TRUE) %>%
  print(n = Inf)
#> # A tibble: 10 x 2
#>    relig                       n
#>    <fct>                   <int>
#>  1 Protestant              10846
#>  2 Catholic                 5124
#>  3 None                     3523
#>  4 Christian                 689
#>  5 Other                     458
#>  6 Jewish                    388
#>  7 Buddhism                  147
#>  8 Inter-nondenominational   109
#>  9 Moslem/islam              104
#> 10 Orthodox-christian         95
15.5.1 Ejercicios
¿Cómo han cambiado con el tiempo las proporciones de personas que se identifican como demócratas, republicanos e independientes?

¿Cómo podría colapsar rincomeen un pequeño conjunto de categorías?

***

## lubridate

16.1 Introducción
Este capítulo le mostrará cómo trabajar con fechas y horas en R. A primera vista, las fechas y las horas parecen simples. Los usas todo el tiempo en tu vida normal, y no parecen causar mucha confusión. Sin embargo, cuanto más aprendes sobre fechas y horarios, más complicados parecen obtenerlos. Para calentar, pruebe estas tres preguntas aparentemente simples:

¿Todos los años tienen 365 días?
¿Todos los días tienen 24 horas?
¿Cada minuto tiene 60 segundos?
Estoy seguro de que sabe que no todos los años tiene 365 días, pero ¿conoce la regla completa para determinar si un año es bisiesto? (Tiene tres partes). Es posible que haya recordado que muchas partes del mundo usan el horario de verano (DST), por lo que algunos días tienen 23 horas y otros tienen 25. Es posible que no sepa que algunos minutos tienen 61 segundos porque de vez en cuando se agregan segundos intercalares porque la rotación de la Tierra se está desacelerando gradualmente.

Las fechas y los tiempos son difíciles porque tienen que conciliar dos fenómenos físicos (la rotación de la Tierra y su órbita alrededor del sol) con una gran cantidad de fenómenos geopolíticos que incluyen meses, zonas horarias y horario de verano. Este capítulo no le enseñará hasta el último detalle sobre fechas y horarios, pero le dará una base sólida de habilidades prácticas que lo ayudarán con los desafíos comunes de análisis de datos.

16.1.1 prerrequisitos
Este capítulo se centrará en el paquete lubridate , que facilita el trabajo con fechas y horas en R. lubridate no forma parte de tidyverse central porque solo lo necesita cuando trabaja con fechas / horas. También necesitaremos nycflights13 para datos de práctica.

library(tidyverse)

library(lubridate)
library(nycflights13)
16.2 Creación de fecha / hora
Hay tres tipos de datos de fecha / hora que se refieren a un instante en el tiempo:

A la fecha . Tibbles imprime esto como <date>.

Un tiempo dentro de un día. Tibbles imprime esto como <time>.

Una fecha-hora es una fecha más una hora: identifica de manera única un instante en el tiempo (generalmente al segundo más cercano). Tibbles imprime esto como <dttm>. En otra parte de R estos se llaman POSIXct, pero no creo que sea un nombre muy útil.

En este capítulo solo nos enfocaremos en fechas y fechas ya que R no tiene una clase nativa para almacenar tiempos. Si necesita uno, puede usar el paquete hms .

Siempre debe usar el tipo de datos más simple posible que funcione para sus necesidades. Eso significa que si puede usar una fecha en lugar de una fecha, debería hacerlo. Los horarios son sustancialmente más complicados debido a la necesidad de manejar zonas horarias, que volveremos al final del capítulo.

Para obtener la fecha actual o la fecha y hora, puede usar today()o now():

today()
#> [1] "2018-06-21"
now()
#> [1] "2018-06-21 03:12:40 UTC"
De lo contrario, hay tres formas en las que es probable que cree una fecha / hora:

De una cadena.
A partir de componentes individuales de fecha y hora.
Desde un objeto de fecha / hora existente.
Funcionan de la siguiente manera.

16.2.1 De cadenas
Los datos de fecha / hora a menudo vienen como cadenas. Has visto un enfoque para analizar cadenas de caracteres en fechas-fechas en el horario . Otro enfoque es usar los ayudantes provistos por lubridate. Automáticamente resuelven el formato una vez que especifica el orden del componente. Para usarlos, identifique el orden en que aparecen el año, el mes y el día en sus fechas, luego organice "y", "m" y "d" en el mismo orden. Eso le da el nombre de la función lubridate que analizará su fecha. Por ejemplo:

ymd("2017-01-31")
#> [1] "2017-01-31"
mdy("January 31st, 2017")
#> [1] "2017-01-31"
dmy("31-Jan-2017")
#> [1] "2017-01-31"
Estas funciones también toman números sin comillas. Esta es la forma más concisa de crear un único objeto de fecha / hora, como puede ser necesario al filtrar datos de fecha / hora. ymd()es corto e inequívoco:

ymd(20170131)
#> [1] "2017-01-31"
ymd()y amigos crean fechas. Para crear una fecha y hora, agregue un guión bajo y una o más de "h", "m" y "s" al nombre de la función de análisis sintáctico:

ymd_hms("2017-01-31 20:11:59")
#> [1] "2017-01-31 20:11:59 UTC"
mdy_hm("01/31/2017 08:01")
#> [1] "2017-01-31 08:01:00 UTC"
También puede forzar la creación de una fecha y hora a partir de una fecha suministrando una zona horaria:

ymd(20170131, tz = "UTC")
#> [1] "2017-01-31 UTC"
16.2.2 De componentes individuales
En lugar de una sola cadena, a veces tendrá los componentes individuales de la fecha y hora distribuidos en varias columnas. Esto es lo que tenemos en los datos de vuelos:

flights %>% 
  select(year, month, day, hour, minute)
#> # A tibble: 336,776 x 5
#>    year month   day  hour minute
#>   <int> <int> <int> <dbl>  <dbl>
#> 1  2013     1     1     5     15
#> 2  2013     1     1     5     29
#> 3  2013     1     1     5     40
#> 4  2013     1     1     5     45
#> 5  2013     1     1     6      0
#> 6  2013     1     1     5     58
#> # ... with 3.368e+05 more rows
Para crear una fecha / hora a partir de este tipo de entrada, utilícela make_date()para fechas o make_datetime()fechas:

flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(departure = make_datetime(year, month, day, hour, minute))
#> # A tibble: 336,776 x 6
#>    year month   day  hour minute departure          
#>   <int> <int> <int> <dbl>  <dbl> <dttm>             
#> 1  2013     1     1     5     15 2013-01-01 05:15:00
#> 2  2013     1     1     5     29 2013-01-01 05:29:00
#> 3  2013     1     1     5     40 2013-01-01 05:40:00
#> 4  2013     1     1     5     45 2013-01-01 05:45:00
#> 5  2013     1     1     6      0 2013-01-01 06:00:00
#> 6  2013     1     1     5     58 2013-01-01 05:58:00
#> # ... with 3.368e+05 more rows
Hagamos lo mismo para cada una de las cuatro columnas de tiempo en flights. Los tiempos están representados en un formato ligeramente extraño, por lo que usamos la aritmética de módulo para extraer los componentes de hora y minuto. Una vez que he creado las variables de fecha y hora, me concentro en las variables que exploraremos en el resto del capítulo.

make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights %>% 
  filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) %>% 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
#> # A tibble: 328,063 x 9
#>   origin dest  dep_delay arr_delay dep_time            sched_dep_time     
#>   <chr>  <chr>     <dbl>     <dbl> <dttm>              <dttm>             
#> 1 EWR    IAH           2        11 2013-01-01 05:17:00 2013-01-01 05:15:00
#> 2 LGA    IAH           4        20 2013-01-01 05:33:00 2013-01-01 05:29:00
#> 3 JFK    MIA           2        33 2013-01-01 05:42:00 2013-01-01 05:40:00
#> 4 JFK    BQN          -1       -18 2013-01-01 05:44:00 2013-01-01 05:45:00
#> 5 LGA    ATL          -6       -25 2013-01-01 05:54:00 2013-01-01 06:00:00
#> 6 EWR    ORD          -4        12 2013-01-01 05:54:00 2013-01-01 05:58:00
#> # ... with 3.281e+05 more rows, and 3 more variables: arr_time <dttm>,
#> #   sched_arr_time <dttm>, air_time <dbl>
Con estos datos, puedo visualizar la distribución de los horarios de salida a lo largo del año:

flights_dt %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day


O en un solo día:

flights_dt %>% 
  filter(dep_time < ymd(20130102)) %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes


Tenga en cuenta que cuando utiliza fechas y horas en un contexto numérico (como en un histograma), 1 significa 1 segundo, por lo que un ancho de 86400 equivale a un día. Para las fechas, 1 significa 1 día.

16.2.3 De otros tipos
Es posible que desee cambiar entre una fecha y una fecha. Ese es el trabajo de as_datetime()y as_date():

as_datetime(today())
#> [1] "2018-06-21 UTC"
as_date(now())
#> [1] "2018-06-21"
Algunas veces obtendrás fecha / hora como compensaciones numéricas de la "Época Unix", 1970-01-01. Si el desplazamiento está en segundos, use as_datetime(); si es en días, use as_date().

as_datetime(60 * 60 * 10)
#> [1] "1970-01-01 10:00:00 UTC"
as_date(365 * 10 + 2)
#> [1] "1980-01-01"
16.2.4 Ejercicios
¿Qué sucede si analiza una cadena que contiene fechas no válidas?

ymd(c("2010-10-10", "bananas"))
¿Qué hace el tzoneargumento para today()hacer? ¿Por qué es importante?

Use la función lubridate apropiada para analizar cada una de las siguientes fechas:

d1 <- "January 1, 2010"
d2 <- "2015-Mar-07"
d3 <- "06-Jun-2017"
d4 <- c("August 19 (2015)", "July 1 (2015)")
d5 <- "12/30/14" # Dec 30, 2014
16.3 Componentes de fecha y hora
Ahora que sabe cómo obtener datos de fecha y hora en las estructuras de datos de fecha y hora de R, exploremos qué puede hacer con ellos. Esta sección se centrará en las funciones de acceso que le permiten obtener y configurar componentes individuales. La siguiente sección verá cómo funciona la aritmética con los tiempos de fecha.

16.3.1 Obteniendo componentes
Puede sacar las piezas individuales de la fecha con las funciones de acceso year(), month(), mday()(día del mes), yday()(los días del año), wday()(día de la semana), hour(), minute(), y second().

datetime <- ymd_hms("2016-07-08 12:34:56")

year(datetime)
#> [1] 2016
month(datetime)
#> [1] 7
mday(datetime)
#> [1] 8

yday(datetime)
#> [1] 190
wday(datetime)
#> [1] 6
Para month()y wday()puede configurar label = TRUEpara devolver el nombre abreviado del mes o el día de la semana. Establecer abbr = FALSEpara devolver el nombre completo.

month(datetime, label = TRUE)
#> [1] Jul
#> 12 Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < ... < Dec
wday(datetime, label = TRUE, abbr = FALSE)
#> [1] Friday
#> 7 Levels: Sunday < Monday < Tuesday < Wednesday < Thursday < ... < Saturday
Podemos utilizar wday()para ver que más vuelos salen durante la semana que en el fin de semana:

flights_dt %>% 
  mutate(wday = wday(dep_time, label = TRUE)) %>% 
  ggplot(aes(x = wday)) +
    geom_bar()


Hay un patrón interesante si observamos el retraso promedio de salida por minuto dentro de una hora. ¡Parece que los vuelos que salen en minutos 20-30 y 50-60 tienen retrasos mucho más bajos que el resto de la hora!

flights_dt %>% 
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()) %>% 
  ggplot(aes(minute, avg_delay)) +
    geom_line()


Curiosamente, si miramos la hora programada de salida, no vemos un patrón tan fuerte:

sched_dep <- flights_dt %>% 
  mutate(minute = minute(sched_dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n())

ggplot(sched_dep, aes(minute, avg_delay)) +
  geom_line()


Entonces, ¿por qué vemos ese patrón con los tiempos reales de salida? Bueno, al igual que muchos datos recopilados por humanos, hay un fuerte sesgo hacia los vuelos que salen en tiempos de salida "agradables". Siempre esté atento a este tipo de patrón siempre que trabaje con datos que involucren el juicio humano.

ggplot(sched_dep, aes(minute, n)) +
  geom_line()


16.3.2 Redondeo
Un enfoque alternativo para el trazado de los componentes individuales es redondear la fecha a una unidad cercana de tiempo, con floor_date(), round_date(), y ceiling_date(). Cada función toma un vector de fechas para ajustar y luego el nombre de la unidad redondea hacia abajo (piso), redondea hacia arriba (techo) o redondea a. Esto, por ejemplo, nos permite trazar el número de vuelos por semana:

flights_dt %>% 
  count(week = floor_date(dep_time, "week")) %>% 
  ggplot(aes(week, n)) +
    geom_line()


Calcular la diferencia entre una fecha redondeada y no redondeada puede ser particularmente útil.

16.3.3 Configuración de componentes
También puede usar cada función de acceso para configurar los componentes de una fecha / hora:

(datetime <- ymd_hms("2016-07-08 12:34:56"))
#> [1] "2016-07-08 12:34:56 UTC"

year(datetime) <- 2020
datetime
#> [1] "2020-07-08 12:34:56 UTC"
month(datetime) <- 01
datetime
#> [1] "2020-01-08 12:34:56 UTC"
hour(datetime) <- hour(datetime) + 1
datetime
#> [1] "2020-01-08 13:34:56 UTC"
Alternativamente, en lugar de modificar en su lugar, puede crear una nueva fecha y hora con update(). Esto también le permite establecer múltiples valores a la vez.

update(datetime, year = 2020, month = 2, mday = 2, hour = 2)
#> [1] "2020-02-02 02:34:56 UTC"
Si los valores son demasiado grandes, se reiniciarán:

ymd("2015-02-01") %>% 
  update(mday = 30)
#> [1] "2015-03-02"
ymd("2015-02-01") %>% 
  update(hour = 400)
#> [1] "2015-02-17 16:00:00 UTC"
Puede usar update()para mostrar la distribución de vuelos a lo largo del día para cada día del año:

flights_dt %>% 
  mutate(dep_hour = update(dep_time, yday = 1)) %>% 
  ggplot(aes(dep_hour)) +
    geom_freqpoly(binwidth = 300)


Establecer componentes más grandes de una fecha en una constante es una poderosa técnica que le permite explorar patrones en los componentes más pequeños.

16.3.4 Ejercicios
¿Cómo cambia la distribución de los tiempos de vuelo en un día a lo largo del año?

Compare dep_time, sched_dep_timey dep_delay. ¿Son consistentes? Explica tus hallazgos

Compare air_timecon la duración entre la partida y la llegada. Explica tus hallazgos (Sugerencia: considere la ubicación del aeropuerto).

¿Cómo cambia el tiempo promedio de demora en el transcurso de un día? ¿Deberías usar dep_timeo sched_dep_time? ¿Por qué?

¿En qué día de la semana debería irse si quiere minimizar la posibilidad de un retraso?

¿Qué hace la distribución de diamonds$caraty flights$sched_dep_timesimilares?

Confirmo mi hipótesis de que las salidas anticipadas de los vuelos en los minutos 20-30 y 50-60 son causadas por vuelos programados que salen temprano. Sugerencia: crea una variable binaria que te diga si un vuelo se retrasó o no.

16.4 Lapso de tiempo
A continuación, aprenderá cómo funciona la aritmética con fechas, incluida la resta, la suma y la división. En el camino, aprenderás acerca de tres clases importantes que representan períodos de tiempo:

duraciones , que representan una cantidad exacta de segundos.
períodos , que representan unidades humanas como semanas y meses.
intervalos , que representan un punto inicial y final.
16.4.1 Duraciones
En R, cuando restas dos fechas, obtienes un objeto de tiempo diferido:

# How old is Hadley?
h_age <- today() - ymd(19791014)
h_age
#> Time difference of 14130 days
Un objeto de clase difftime registra un lapso de tiempo de segundos, minutos, horas, días o semanas. Esta ambigüedad puede hacer que sea un poco doloroso trabajar con ella, por lo que lubridate proporciona una alternativa que siempre usa segundos: la duración .

as.duration(h_age)
#> [1] "1220832000s (~38.69 years)"
Las duraciones vienen con un grupo de constructores convenientes:

dseconds(15)
#> [1] "15s"
dminutes(10)
#> [1] "600s (~10 minutes)"
dhours(c(12, 24))
#> [1] "43200s (~12 hours)" "86400s (~1 days)"
ddays(0:5)
#> [1] "0s"                "86400s (~1 days)"  "172800s (~2 days)"
#> [4] "259200s (~3 days)" "345600s (~4 days)" "432000s (~5 days)"
dweeks(3)
#> [1] "1814400s (~3 weeks)"
dyears(1)
#> [1] "31536000s (~52.14 weeks)"
Las duraciones siempre registran el lapso de tiempo en segundos. Las unidades más grandes se crean mediante la conversión de minutos, horas, días, semanas y años a segundos a la velocidad estándar (60 segundos en un minuto, 60 minutos en una hora, 24 horas en día, 7 días a la semana, los 365 días en una año).

Puede agregar y multiplicar duraciones:

2 * dyears(1)
#> [1] "63072000s (~2 years)"
dyears(1) + dweeks(12) + dhours(15)
#> [1] "38847600s (~1.23 years)"
Puede agregar y restar duraciones ay desde días:

tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
Sin embargo, dado que las duraciones representan una cantidad exacta de segundos, a veces puede obtener un resultado inesperado:

one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")

one_pm
#> [1] "2016-03-12 13:00:00 EST"
one_pm + ddays(1)
#> [1] "2016-03-13 14:00:00 EDT"
¿Por qué un día después de la 1 pm el 12 de marzo, a las 2 p.m. el 13 de marzo? Si observa detenidamente la fecha, también puede observar que las zonas horarias han cambiado. Debido a DST, el 12 de marzo solo tiene 23 horas, por lo que si agregamos un valor de segundos de días completos, terminamos con un horario diferente.

16.4.2 Períodos
Para resolver este problema, lubridate proporciona periodos . Los períodos son períodos de tiempo, pero no tienen una duración fija en segundos, sino que funcionan con tiempos "humanos", como días y meses. Eso les permite trabajar de una manera más intuitiva:

one_pm
#> [1] "2016-03-12 13:00:00 EST"
one_pm + days(1)
#> [1] "2016-03-13 13:00:00 EDT"
Al igual que las duraciones, los períodos se pueden crear con varias funciones amigables de constructor.

seconds(15)
#> [1] "15S"
minutes(10)
#> [1] "10M 0S"
hours(c(12, 24))
#> [1] "12H 0M 0S" "24H 0M 0S"
days(7)
#> [1] "7d 0H 0M 0S"
months(1:6)
#> [1] "1m 0d 0H 0M 0S" "2m 0d 0H 0M 0S" "3m 0d 0H 0M 0S" "4m 0d 0H 0M 0S"
#> [5] "5m 0d 0H 0M 0S" "6m 0d 0H 0M 0S"
weeks(3)
#> [1] "21d 0H 0M 0S"
years(1)
#> [1] "1y 0m 0d 0H 0M 0S"
Puedes agregar y multiplicar periodos:

10 * (months(6) + days(1))
#> [1] "60m 10d 0H 0M 0S"
days(50) + hours(25) + minutes(2)
#> [1] "50d 25H 2M 0S"
Y, por supuesto, agréguelos a las fechas. En comparación con las duraciones, los períodos tienen más probabilidades de hacer lo que esperas:

# A leap year
ymd("2016-01-01") + dyears(1)
#> [1] "2016-12-31"
ymd("2016-01-01") + years(1)
#> [1] "2017-01-01"

# Daylight Savings Time
one_pm + ddays(1)
#> [1] "2016-03-13 14:00:00 EDT"
one_pm + days(1)
#> [1] "2016-03-13 13:00:00 EDT"
Usemos períodos para arreglar una rareza relacionada con nuestras fechas de vuelo. Algunos aviones parecen haber llegado a su destino antes de partir de la ciudad de Nueva York.

flights_dt %>% 
  filter(arr_time < dep_time) 
#> # A tibble: 10,633 x 9
#>   origin dest  dep_delay arr_delay dep_time            sched_dep_time     
#>   <chr>  <chr>     <dbl>     <dbl> <dttm>              <dttm>             
#> 1 EWR    BQN           9        -4 2013-01-01 19:29:00 2013-01-01 19:20:00
#> 2 JFK    DFW          59        NA 2013-01-01 19:39:00 2013-01-01 18:40:00
#> 3 EWR    TPA          -2         9 2013-01-01 20:58:00 2013-01-01 21:00:00
#> 4 EWR    SJU          -6       -12 2013-01-01 21:02:00 2013-01-01 21:08:00
#> 5 EWR    SFO          11       -14 2013-01-01 21:08:00 2013-01-01 20:57:00
#> 6 LGA    FLL         -10        -2 2013-01-01 21:20:00 2013-01-01 21:30:00
#> # ... with 1.063e+04 more rows, and 3 more variables: arr_time <dttm>,
#> #   sched_arr_time <dttm>, air_time <dbl>
Estos son vuelos nocturnos. Utilizamos la misma información de fecha tanto para la hora de salida como para la hora de llegada, pero estos vuelos llegaron al día siguiente. Podemos solucionar esto añadiendo days(1)el tiempo de llegada de cada vuelo nocturno.

flights_dt <- flights_dt %>% 
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight * 1),
    sched_arr_time = sched_arr_time + days(overnight * 1)
  )
Ahora todos nuestros vuelos obedecen las leyes de la física.

flights_dt %>% 
  filter(overnight, arr_time < dep_time) 
#> # A tibble: 0 x 10
#> # ... with 10 variables: origin <chr>, dest <chr>, dep_delay <dbl>,
#> #   arr_delay <dbl>, dep_time <dttm>, sched_dep_time <dttm>,
#> #   arr_time <dttm>, sched_arr_time <dttm>, air_time <dbl>,
#> #   overnight <lgl>
16.4.3 Intervalos
Es obvio lo que dyears(1) / ddays(365)debería regresar: uno, porque las duraciones siempre están representadas por una cantidad de segundos, y una duración de un año se define como 365 días en segundos.

¿Qué debería years(1) / days(1)regresar? Bueno, si el año fue 2015 debería devolver 365, pero si fuera 2016, ¡debería devolver 366! No hay suficiente información para que lubridate brinde una única respuesta clara. Lo que hace en cambio es dar una estimación, con una advertencia:

years(1) / days(1)
#> estimate only: convert to intervals for accuracy
#> [1] 365
Si quieres una medida más precisa, tendrás que usar un intervalo . Un intervalo es una duración con un punto de inicio: eso lo hace preciso para que pueda determinar exactamente cuánto tiempo es:

next_year <- today() + years(1)
(today() %--% next_year) / ddays(1)
#> [1] 365
Para saber cuántos períodos entran en un intervalo, debe usar la división de enteros:

(today() %--% next_year) %/% days(1)
#> Note: method with signature 'Timespan#Timespan' chosen for function '%/%',
#>  target signature 'Interval#Period'.
#>  "Interval#ANY", "ANY#Period" would also be valid
#> [1] 365
16.4.4 Resumen
¿Cómo se elige entre duración, períodos e intervalos? Como siempre, elija la estructura de datos más simple que resuelva su problema. Si solo te importa el tiempo físico, usa una duración; si necesita agregar tiempos humanos, use un punto; si necesita saber cuánto tiempo dura un lapso en unidades humanas, use un intervalo.

La Figura 16.1 resume las operaciones aritméticas permitidas entre los diferentes tipos de datos.

 Las operaciones aritméticas permitidas entre pares de clases de fecha / hora.
Figura 16.1: Las operaciones aritméticas permitidas entre pares de clases de fecha / hora.

16.4.5 Ejercicios
¿Por qué hay months()pero no dmonths()?

Explíquele days(overnight * 1)a alguien que acaba de comenzar a aprender R. ¿Cómo funciona?

Cree un vector de fechas para el primer día de cada mes en 2015. Cree un vector de fechas que indique el primer día de cada mes en el año actual .

Escriba una función que, dada su fecha de cumpleaños (como fecha), devuelva la edad que tenga en años.

¿Por qué no puede (today() %--% (today() + years(1)) / months(1)funcionar?

16.5 Zonas horarias
Las zonas horarias son un tema enormemente complicado debido a su interacción con entidades geopolíticas. Afortunadamente, no necesitamos profundizar en todos los detalles, ya que no son todos importantes para el análisis de datos, pero hay algunos desafíos que debemos enfrentar.

El primer desafío es que los nombres diarios de las zonas horarias tienden a ser ambiguos. Por ejemplo, si eres estadounidense, probablemente estés familiarizado con EST o Eastern Standard Time. Sin embargo, tanto Australia como Canadá también tienen EST. Para evitar confusiones, R usa las zonas horarias estándar internacionales de IANA. Estos usan un esquema de nombres consistente "/", Típicamente en la forma" <continente> / <ciudad> "(hay algunas excepciones porque no todos los países se encuentran en un continente). Los ejemplos incluyen "America / New_York", "Europe / Paris" y "Pacific / Auckland".

Quizás se pregunte por qué la zona horaria utiliza una ciudad, cuando normalmente piensa en zonas horarias asociadas a un país o región dentro de un país. Esto se debe a que la base de datos IANA tiene que registrar décadas de reglas de zona horaria. En el transcurso de las décadas, los países cambian los nombres (o se separan) con bastante frecuencia, pero los nombres de las ciudades tienden a permanecer igual. Otro problema es que el nombre debe reflejar no solo el comportamiento actual, sino también el historial completo. Por ejemplo, hay zonas horarias para "America / New_York" y "America / Detroit". Ambas ciudades actualmente usan Eastern Standard Time, pero en 1969-1972 Michigan (el estado en el que se encuentra Detroit) no siguió el horario de verano, por lo que necesita un nombre diferente. Vale la pena leer la base de datos de la zona horaria en bruto (disponible en http://www.iana.org/time-zones) solo para leer algunas de estas historias!

Puedes descubrir con qué piensa R tu zona horaria actual Sys.timezone():

Sys.timezone()
#> [1] "UTC"
(Si R no sabe, obtendrá una NA.)

Y vea la lista completa de todos los nombres de zona horaria con OlsonNames():

length(OlsonNames())
#> [1] 606
head(OlsonNames())
#> [1] "Africa/Abidjan"     "Africa/Accra"       "Africa/Addis_Ababa"
#> [4] "Africa/Algiers"     "Africa/Asmara"      "Africa/Asmera"
En R, la zona horaria es un atributo de la fecha y hora que solo controla la impresión. Por ejemplo, estos tres objetos representan el mismo instante en el tiempo:

(x1 <- ymd_hms("2015-06-01 12:00:00", tz = "America/New_York"))
#> [1] "2015-06-01 12:00:00 EDT"
(x2 <- ymd_hms("2015-06-01 18:00:00", tz = "Europe/Copenhagen"))
#> [1] "2015-06-01 18:00:00 CEST"
(x3 <- ymd_hms("2015-06-02 04:00:00", tz = "Pacific/Auckland"))
#> [1] "2015-06-02 04:00:00 NZST"
Puedes verificar que son el mismo tiempo que usas la resta:

x1 - x2
#> Time difference of 0 secs
x1 - x3
#> Time difference of 0 secs
A menos que se especifique lo contrario, lubridate siempre usa UTC. UTC (tiempo universal coordinado) es la zona horaria estándar utilizada por la comunidad científica y más o menos equivalente a su predecesor, GMT (Greenwich Mean Time). No tiene horario de verano, lo que hace una representación conveniente para el cálculo. Las operaciones que combinan fechas y horas, como c(), a menudo disminuirán la zona horaria. En ese caso, los horarios se mostrarán en su zona horaria local:

x4 <- c(x1, x2, x3)
x4
#> [1] "2015-06-01 12:00:00 EDT" "2015-06-01 12:00:00 EDT"
#> [3] "2015-06-01 12:00:00 EDT"
Puede cambiar la zona horaria de dos maneras:

Mantenga el mismo instante a tiempo y cambie la forma en que se muestra. Úselo cuando el instante sea correcto, pero desea una visualización más natural.

x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
x4a
#> [1] "2015-06-02 02:30:00 +1030" "2015-06-02 02:30:00 +1030"
#> [3] "2015-06-02 02:30:00 +1030"
x4a - x4
#> Time differences in secs
#> [1] 0 0 0
(Esto también ilustra otro desafío de las zonas de tiempo: ¡no son todas las compensaciones de horas enteras!)

Cambia el instante subyacente a tiempo. Úselo cuando tenga un instante que haya sido etiquetado con la zona horaria incorrecta, y necesita repararlo.

x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
x4b
#> [1] "2015-06-01 12:00:00 +1030" "2015-06-01 12:00:00 +1030"
#> [3] "2015-06-01 12:00:00 +1030"
x4b - x4
#> Time differences in hours
#> [1] -14.5 -14.5 -14.5


#### Ejercicios
En el código que no usa stringr, a menudo verá paste()y paste0(). ¿Cuál es la diferencia entre las dos funciones? ¿A qué función stringr son equivalentes? ¿Cómo difieren las funciones en su manejo NA?

En sus propias palabras, describa la diferencia entre the sepy collapse arguments to str_c().

Usa str_length()y str_sub()para extraer el carácter medio de una cadena. ¿Qué harás si la cadena tiene un número par de caracteres?

Que hace str_wrap()? ¿Cuándo podría querer usarlo?

Que hace str_trim()? ¿Qué es lo opuesto a str_trim()?

Escriba una función que gire (p. Ej.) Un vector c("a", "b", "c")en la cadena a, b, and c. Piense con cuidado sobre lo que debería hacer si se le da un vector de longitud 0, 1 o 2.

Explicar por qué cada una de estas cadenas no coinciden con un \: "\", "\\", "\\\".

¿Cómo coincidirías con la secuencia "'\?

¿Qué patrones \..\..\..concuerda con la expresión regular ? ¿Cómo lo representarías como una cadena?

¿Cómo coincidirías con la cadena literal "$^$"?

Dado el corpus de palabras comunes en stringr::words, crea expresiones regulares que encuentren todas las palabras que:

Comience con "y".
Terminar con "x"
Son exactamente tres letras de largo. (¡No haga trampa al usar str_length()!)
Tener siete letras o más.
Dado que esta lista es larga, es posible que desee utilizar el matchargumento str_view()para mostrar solo las palabras coincidentes o no coincidentes.

Crea expresiones regulares para encontrar todas las palabras que:

Comience con una vocal.

Eso solo contiene consonantes. (Sugerencia: pensando en emparejar "no" -vowels).

Termine con ed, pero no con eed.

Termine con ingo ise.

Verifica empíricamente la regla "i antes de e, excepto después de c".

¿A "q" siempre le sigue una "u"?

Escribe una expresión regular que coincida con una palabra si es probable que esté escrita en inglés británico, no en inglés americano.

Cree una expresión regular que coincida con los números de teléfono escritos comúnmente en su país.

Describir las equivalentes de ?, +, *en {m,n}la forma.

Describa en palabras lo que estas expresiones regulares coinciden: (lea cuidadosamente para ver si estoy usando una expresión regular o una cadena que define una expresión regular).

^.*$
"\\{.+\\}"
\d{4}-\d{2}-\d{2}
"\\\\{4}"
Crea expresiones regulares para encontrar todas las palabras que:

Comience con tres consonantes.
Tener tres o más vocales seguidas.
Tener dos o más parejas de vocales y consonantes seguidas.
Resuelve los crucigramas de la expresión regular para principiantes en https://regexcrossword.com/challenges/beginner.

Describa, en palabras, qué concuerdan estas expresiones:

(.)\1\1
"(.)(.)\\2\\1"
(..)\1
"(.).\\1.\\1"
"(.)(.)(.).*\\3\\2\\1"
Construya expresiones regulares para unir palabras que:

Comience y termine con el mismo personaje.

Contiene un par de letras repetidas (por ejemplo, "iglesia" contiene "ch" repetido dos veces).

Contiene una letra repetida en al menos tres lugares (por ejemplo, "once" contiene tres "e" s).

Para cada uno de los siguientes desafíos, intente resolverlo utilizando una sola expresión regular y una combinación de str_detect()llamadas múltiples .

Encuentra todas las palabras que comienzan o terminan x.

Encuentra todas las palabras que comienzan con una vocal y terminan con una consonante.

¿Hay alguna palabra que contenga al menos una de cada vocal diferente?

¿Qué palabra tiene el mayor número de vocales? ¿Qué palabra tiene la mayor proporción de vocales? (Sugerencia: ¿cuál es el denominador?)
