---
title: "Ciencia de Datos con R"
subtitle: "3. INEGI & Twitter API's"
author: "Ana Sustaita, sustaitaana@gmail.com"
output:
  html_document:
    df_print: paged
    highlight: tango
    theme: flatly
  pdf_document: default
  word_document: default
---

![](../images/greenshark.png)

# {.tabset .tabset-fade .tabset-pills}

## stringr

`stringr` no es parte del `tidyverse`, por lo que debemos instalarlo y cargarlo explícitamente.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(stringr)
```

### Conceptos básicos

Podemos crear cadenas con comillas simples o comillas dobles. A diferencia de otros lenguajes, no hay diferencia en el comportamiento. Es recomendable usar siempre `"`, a menos que queramos crear una cadena que contenga múltiples comillas dobles.

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
string1 <- "Esto es una cadena"
string2 <- 'Si queremos incluir una "cita" dentro de una cadena, usamos comillas simples'
```

Si olvidamos cerrar una cadena, veremos `+`, el caracter de continuación:

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
# > "Esta es una cadena sin comillas de cierre
# + 
# + 
# + AYUDA, ESTOY ATORADO!
```

Si esto nos pasa, sólo debemos presionar Escape e intentar nuevamente.

Para incluir una comilla simple o doble literal en una cadena, podemos usar `\` para "escaparla":

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
double_quote <- "\"" # o '"'
single_quote <- '\'' # o "'"
```

Esto significa que si deseamos incluir una barra invertida, tendremos que duplicarla: "\\".

Debemos tener en cuenta que la representación impresa de una cadena no es la misma que la cadena por si misma, esto se debe a que la representación impresa muestra los escapes. Para ver el contenido "crudo" de la cadena, usamos `writeLines()`:

```{r, message=FALSE, warning=FALSE}
x <- c("\"", "\\")
x

writeLines(x)
```

Hay un puñado de otros caracteres especiales. Los más comunes son `"\n"`, nueva línea y `"\t"`, tab, pero podemos ver la lista completa en la ayuda de `"`: `?'"'` o `?"'"`. En ocasiones nos podemos encontrar con cadenas como `"\u00b5"` esta es una forma de escribir caracteres no alfabéticos que funcionan en todas las plataformas:

```{r, message=FALSE, warning=FALSE}
x <- "\u00b5"
x
```

Múltiples cadenas a menudo se almacenan en un vector de caracteres, que podemos crear con c():

```{r, message=FALSE, warning=FALSE}
c("one", "two", "three")
```

#### Longitud

La Base R contiene muchas funciones para trabajar con cadenas pero las evitaremos porque pueden ser inconsistentes, lo que las hace difíciles de recordar. En su lugar usaremos funciones de stringr. Estos tienen nombres más intuitivos, y todos comienzan con str_. Por ejemplo, str_length()te dice la cantidad de caracteres en una cadena:

str_length(c("a", "R for data science", NA))
#> [1]  1 18 NA
El str_prefijo común es particularmente útil si utiliza RStudio, porque el tipeo str_activará la función autocompletar, lo que le permite ver todas las funciones del stringr:



14.2.2 Combinando cadenas
Para combinar dos o más cadenas, use str_c():

str_c("x", "y")
#> [1] "xy"
str_c("x", "y", "z")
#> [1] "xyz"
Usa el separgumento para controlar cómo están separados:

str_c("x", "y", sep = ", ")
#> [1] "x, y"
Como la mayoría de las otras funciones en R, los valores faltantes son contagiosos. Si desea que se impriman como "NA", use str_replace_na():

x <- c("abc", NA)
str_c("|-", x, "-|")
#> [1] "|-abc-|" NA
str_c("|-", str_replace_na(x), "-|")
#> [1] "|-abc-|" "|-NA-|"
Como se muestra arriba, str_c()se vectoriza, y recicla automáticamente vectores más cortos a la misma longitud que el más largo:

str_c("prefix-", c("a", "b", "c"), "-suffix")
#> [1] "prefix-a-suffix" "prefix-b-suffix" "prefix-c-suffix"
Los objetos de longitud 0 se eliminan en silencio. Esto es particularmente útil en conjunción con if:

name <- "Hadley"
time_of_day <- "morning"
birthday <- FALSE

str_c(
  "Good ", time_of_day, " ", name,
  if (birthday) " and HAPPY BIRTHDAY",
  "."
)
#> [1] "Good morning Hadley."
Para contraer un vector de cadenas en una sola cadena, use collapse:

str_c(c("x", "y", "z"), collapse = ", ")
#> [1] "x, y, z"
14.2.3 Cadenas de subconjuntos
Puedes extraer partes de una cadena usando str_sub(). Además de la cadena, las str_sub()tomas starty los endargumentos que dan la posición (inclusiva) de la subcadena:

x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)
#> [1] "App" "Ban" "Pea"
# negative numbers count backwards from end
str_sub(x, -3, -1)
#> [1] "ple" "ana" "ear"
Tenga en cuenta que str_sub()no fallará si la cadena es demasiado corta: solo regresará tanto como sea posible:

str_sub("a", 1, 5)
#> [1] "a"
También puede usar la forma de asignación de str_sub()para modificar cadenas:

str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))
x
#> [1] "apple"  "banana" "pear"
14.2.4 Locales
Arriba solía str_to_lower()cambiar el texto a minúsculas. También puedes usar str_to_upper()o str_to_title(). Sin embargo, cambiar de mayúsculas a minúsculas es más complicado de lo que podría parecer a primera vista, ya que los diferentes idiomas tienen diferentes reglas para cambiar de mayúscula a minúscula. Puede elegir qué conjunto de reglas usar al especificar una configuración regional:

# Turkish has two i's: with and without a dot, and it
# has a different rule for capitalising them:
str_to_upper(c("i", "ı"))
#> [1] "I" "I"
str_to_upper(c("i", "ı"), locale = "tr")
#> [1] "İ" "I"
La configuración regional se especifica como un código de idioma ISO 639, que es una abreviación de dos o tres letras. Si aún no conoce el código de su idioma, Wikipedia tiene una buena lista. Si deja la configuración regional en blanco, usará la configuración regional actual, tal como lo proporciona su sistema operativo.

Otra operación importante que se ve afectada por la configuración regional es la clasificación. La base R order()y las sort()funciones clasifican cadenas usando la configuración regional actual. Si desea un comportamiento robusto en diferentes computadoras, es posible que desee utilizar str_sort()y str_order()que tome un localeargumento adicional :

x <- c("apple", "eggplant", "banana")

str_sort(x, locale = "en")  # English
#> [1] "apple"    "banana"   "eggplant"

str_sort(x, locale = "haw") # Hawaiian
#> [1] "apple"    "eggplant" "banana"
14.2.5 Ejercicios
En el código que no usa stringr, a menudo verá paste()y paste0(). ¿Cuál es la diferencia entre las dos funciones? ¿A qué función stringr son equivalentes? ¿Cómo difieren las funciones en su manejo NA?

En sus propias palabras, describa la diferencia entre the sepy collapse arguments to str_c().

Usa str_length()y str_sub()para extraer el carácter medio de una cadena. ¿Qué harás si la cadena tiene un número par de caracteres?

Que hace str_wrap()? ¿Cuándo podría querer usarlo?

Que hace str_trim()? ¿Qué es lo opuesto a str_trim()?

Escriba una función que gire (p. Ej.) Un vector c("a", "b", "c")en la cadena a, b, and c. Piense con cuidado sobre lo que debería hacer si se le da un vector de longitud 0, 1 o 2.

14.3 Patrones coincidentes con expresiones regulares
Regexps es un lenguaje muy lacónico que le permite describir patrones en cadenas. Toman un poco de tiempo para entender, pero una vez que los entiendas, los encontrarás extremadamente útiles.

Para aprender expresiones regulares, usaremos str_view()y str_view_all(). Estas funciones toman un vector de caracteres y una expresión regular, y le muestran cómo coinciden. Comenzaremos con expresiones regulares muy simples y luego gradualmente nos volveremos más y más complicados. Una vez que domine la coincidencia de patrones, aprenderá cómo aplicar esas ideas con varias funciones de cadena.

14.3.1 Partidos básicos
Los patrones más simples coinciden con cadenas exactas:

x <- c("apple", "banana", "pear")
str_view(x, "an")
manzana
b an ana
Pera
El siguiente paso en la complejidad es ., que coincide con cualquier personaje (excepto una nueva línea):

str_view(x, ".a.")
manzana
ban ana
p oreja
Pero si " ." coincide con cualquier personaje, ¿cómo se relaciona el personaje " ."? Debe usar un "escape" para decir exactamente la expresión regular con la que desea hacer coincidir, no usar su comportamiento especial. Al igual que las cadenas, las expresiones regulares usan la barra invertida,, \para escapar del comportamiento especial. Entonces, para que coincida con una ., necesitas la expresión regular \.. Lamentablemente, esto crea un problema. Usamos cadenas para representar expresiones regulares, y \también se usa como un símbolo de escape en cadenas. Entonces para crear la expresión regular \.necesitamos la cadena "\\.".

# To create the regular expression, we need \\
dot <- "\\."

# But the expression itself only contains one:
writeLines(dot)
#> \.

# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")
a B C
C.A
bef
Si \se usa como un carácter de escape en expresiones regulares, ¿cómo se combina un literal \? Bueno, necesitas escapar, creando la expresión regular \\. Para crear esa expresión regular, necesita usar una cadena, que también necesita escapar \. Eso significa hacer coincidir un literal \que necesita escribir "\\\\": ¡necesita cuatro barras invertidas para que coincida con uno!

x <- "a\\b"
writeLines(x)
#> a\b

str_view(x, "\\\\")
a \ b
En este libro, escribiré la expresión regular como \.y las cadenas que representan la expresión regular como "\\.".

14.3.1.1 Ejercicios
Explicar por qué cada una de estas cadenas no coinciden con un \: "\", "\\", "\\\".

¿Cómo coincidirías con la secuencia "'\?

¿Qué patrones \..\..\..concuerda con la expresión regular ? ¿Cómo lo representarías como una cadena?

14.3.2 Anclajes
Por defecto, las expresiones regulares coincidirán con cualquier parte de una cadena. A menudo es útil anclar la expresión regular para que coincida desde el principio o el final de la cadena. Puedes usar:

^ para que coincida con el comienzo de la cadena.
$ para unir el final de la cuerda.
x <- c("apple", "banana", "pear")
str_view(x, "^a")
un pple
plátano
Pera
str_view(x, "a$")
manzana
banan a
Pera
Para recordar cuál es cuál, prueba esta mnemotecnia que aprendí de Evan Misshula : si comienzas con power ( ^), terminas con dinero ( $).

Para forzar una expresión regular que solo coincida con una cadena completa, anclarla con ambos ^y $:

x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")
tarta de manzana
manzana
pastel de manzana
str_view(x, "^apple$")
pie de manzana
manzana
tarta de manzana
También puede coincidir el límite entre las palabras con \b. No suelo usar esto en R, pero a veces lo uso cuando realizo una búsqueda en RStudio cuando quiero encontrar el nombre de una función que es un componente de otras funciones. Por ejemplo, voy a buscar para \bsum\bevitar coincidencia summarise, summary, rowsumy así sucesivamente.

14.3.2.1 Ejercicios
¿Cómo coincidirías con la cadena literal "$^$"?

Dado el corpus de palabras comunes en stringr::words, crea expresiones regulares que encuentren todas las palabras que:

Comience con "y".
Terminar con "x"
Son exactamente tres letras de largo. (¡No haga trampa al usar str_length()!)
Tener siete letras o más.
Dado que esta lista es larga, es posible que desee utilizar el matchargumento str_view()para mostrar solo las palabras coincidentes o no coincidentes.

14.3.3 Clases de caracteres y alternativas
Hay una serie de patrones especiales que coinciden con más de un personaje. Ya has visto ., que coincide con cualquier personaje aparte de una nueva línea. Hay otras cuatro herramientas útiles:

\d: coincide con cualquier dígito.
\s: coincide con cualquier espacio en blanco (por ejemplo, espacio, pestaña, nueva línea).
[abc]: coincide con a, b, o c.
[^abc]: coincide con cualquier cosa excepto a, b, o c.
Recuerde, para crear una expresión regular que contenga \do \s, deberá escaparse \de la cadena, por lo que deberá escribir "\\d"o "\\s".

Una clase de caracteres que contenga un solo carácter es una buena alternativa a los escapes de barra invertida cuando se desea incluir un metacarácter único en una expresión regular. Muchas personas lo encuentran más legible.

# Look for a literal character that normally has special meaning in a regex
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")
a B C
C.A
C.A
C.A
str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")
a B C
C.A
C.A
C.A
str_view(c("abc", "a.c", "a*c", "a c"), "a[ ]")
a B C
C.A
C.A
a c
Esto funciona para la mayoría de los metacaracteres de expresiones regulares (pero no todos): $ . | ? * + ( ) [ {. Desafortunadamente, algunos caracteres tienen un significado especial incluso dentro de una clase de caracteres y deben manejarse con escapes de barra invertida: ] \ ^y -.

Puede usar la alternancia para elegir uno o más patrones alternativos. Por ejemplo, abc|d..fcoincidirá con '' abc '' o "deaf". Tenga en cuenta que la precedencia para |es baja, por lo que abc|xyzcoincide abco xyzno abcyzo abxyz. Al igual que con las expresiones matemáticas, si la precedencia se vuelve confusa, use paréntesis para dejar en claro lo que desea:

str_view(c("grey", "gray"), "gr(e|a)y")
gris
gris
14.3.3.1 Ejercicios
Crea expresiones regulares para encontrar todas las palabras que:

Comience con una vocal.

Eso solo contiene consonantes. (Sugerencia: pensando en emparejar "no" -vowels).

Termine con ed, pero no con eed.

Termine con ingo ise.

Verifica empíricamente la regla "i antes de e, excepto después de c".

¿A "q" siempre le sigue una "u"?

Escribe una expresión regular que coincida con una palabra si es probable que esté escrita en inglés británico, no en inglés americano.

Cree una expresión regular que coincida con los números de teléfono escritos comúnmente en su país.

14.3.4 Repetición
El siguiente paso en el poder implica controlar cuántas veces coincide un patrón:

?: 0 o 1
+: 1 o más
*: 0 o más
x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")
1888 es el año más largo en números romanos: MD CC CLXXXVIII
str_view(x, "CC+")
1888 es el año más largo en números romanos: MD CCC LXXXVIII
str_view(x, 'C[LX]+')
1888 es el año más largo en números romanos: MDCC CLXXX VIII
Tenga en cuenta que la precedencia de estos operadores es alta, por lo que puede escribir: colou?rpara que coincida con la ortografía estadounidense o británica. Eso significa que la mayoría de los usos necesitarán paréntesis, como bana(na)+.

También puede especificar el número de coincidencias con precisión:

{n}: exactamente n
{n,}: n o más
{,m}: a lo sumo m
{n,m}: entre n y m
str_view(x, "C{2}")
1888 es el año más largo en números romanos: MD CC CLXXXVIII
str_view(x, "C{2,}")
1888 es el año más largo en números romanos: MD CCC LXXXVIII
str_view(x, "C{2,3}")
1888 es el año más largo en números romanos: MD CCC LXXXVIII
Por defecto, estas coincidencias son "codiciosas": coincidirán con la cadena más larga posible. Puede hacer que sean "flojos", haciendo coincidir la cadena más corta posible poniendo una ?después de ellos. Esta es una característica avanzada de las expresiones regulares, pero es útil saber que existe:

str_view(x, 'C{2,3}?')
1888 es el año más largo en números romanos: MD CC CLXXXVIII
str_view(x, 'C[LX]+?')
1888 es el año más largo en números romanos: MDCC CL XXXVIII
14.3.4.1 Ejercicios
Describir las equivalentes de ?, +, *en {m,n}la forma.

Describa en palabras lo que estas expresiones regulares coinciden: (lea cuidadosamente para ver si estoy usando una expresión regular o una cadena que define una expresión regular).

^.*$
"\\{.+\\}"
\d{4}-\d{2}-\d{2}
"\\\\{4}"
Crea expresiones regulares para encontrar todas las palabras que:

Comience con tres consonantes.
Tener tres o más vocales seguidas.
Tener dos o más parejas de vocales y consonantes seguidas.
Resuelve los crucigramas de la expresión regular para principiantes en https://regexcrossword.com/challenges/beginner .

14.3.5 Agrupación y referencias
Anteriormente, aprendió acerca de los paréntesis como una forma de desambiguar expresiones complejas. Los paréntesis también crean un grupo de captura numerado (número 1, 2, etc.). Un grupo de captura almacena la parte de la cadena que coincide con la parte de la expresión regular dentro de los paréntesis. Puede consultar el mismo texto que un grupo de captura con referencias anteriores , como \1, \2por ejemplo, etc. Por ejemplo, la siguiente expresión regular encuentra todas las frutas que tienen un par de letras repetidas.

str_view(fruit, "(..)\\1", match = TRUE)
b anan a
nuez de coco
cucu mber
juju sea
papa ya
s alal berry
(En breve, también verá cómo son útiles junto con str_match().)

14.3.5.1 Ejercicios
Describa, en palabras, qué concuerdan estas expresiones:

(.)\1\1
"(.)(.)\\2\\1"
(..)\1
"(.).\\1.\\1"
"(.)(.)(.).*\\3\\2\\1"
Construya expresiones regulares para unir palabras que:

Comience y termine con el mismo personaje.

Contiene un par de letras repetidas (por ejemplo, "iglesia" contiene "ch" repetido dos veces).

Contiene una letra repetida en al menos tres lugares (por ejemplo, "once" contiene tres "e" s).

14.4 Herramientas
Ahora que ha aprendido los conceptos básicos de las expresiones regulares, es hora de aprender cómo aplicarlas a problemas reales. En esta sección, aprenderá una amplia gama de funciones stringr que le permiten:

Determine qué cadenas coinciden con un patrón.
Encuentra las posiciones de los partidos.
Extrae el contenido de las coincidencias.
Reemplazar coincidencias con nuevos valores.
Dividir una cadena basada en una coincidencia.
Una palabra de advertencia antes de continuar: dado que las expresiones regulares son tan poderosas, es fácil tratar de resolver cada problema con una sola expresión regular. En palabras de Jamie Zawinski:

Algunas personas, cuando se enfrentan con un problema, piensan "Lo sé, usaré expresiones regulares". Ahora tienen dos problemas.

Como una advertencia, echa un vistazo a esta expresión regular que verifica si una dirección de correo electrónico es válida:

(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\["()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:
\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(
?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ 
\t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\0
31]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\
](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+
(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:
(?:\r\n)?[ \t])*))*|(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\["()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)
?[ \t])*)*\<(?:(?:\r\n)?[ \t])*(?:@(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\
r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[
 \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)
?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t]
)*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[
 \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*
)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]
)+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)
*:(?:(?:\r\n)?[ \t])*)?(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+
|\Z|(?=[\["()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r
\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:
\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t
]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031
]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](
?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?
:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?
:\r\n)?[ \t])*))*\>(?:(?:\r\n)?[ \t])*)|(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?
:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?
[ \t]))*"(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()<>@,;:\\".\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|
\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>
@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|"
(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t]
)*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\
".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?
:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[
\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()<>@,;:\\".\[\] \000-
\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(
?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\<(?:(?:\r\n)?[ \t])*(?:@(?:[^()<>@,;
:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([
^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\"
.\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\
]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\
[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\
r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] 
\000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]
|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()<>@,;:\\".\[\] \0
00-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\
.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,
;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|"(?
:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*
(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".
\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[
^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\]
]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\>(?:(?:\r\n)?[ \t])*)(?:,\s*(
?:(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\
".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(
?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[
\["()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t
])*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t
])+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?
:\.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|
\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:
[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".\[\
]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\<(?:(?:\r\n)
?[ \t])*(?:@(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["
()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)
?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>
@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[
 \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,
;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t]
)*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\
".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?
(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()<>@,;:\\".
\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:
\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[
"()<>@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])
*))*@(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])
+|\Z|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\
.(?:(?:\r\n)?[ \t])*(?:[^()<>@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z
|(?=[\["()<>@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\>(?:(
?:\r\n)?[ \t])*))*)?;\s*)
Este es un ejemplo algo patológico (porque las direcciones de correo electrónico son en realidad sorprendentemente complejas), pero se usa en código real. Consulte la discusión de stackoverflow en http://stackoverflow.com/a/201378 para obtener más detalles.

No olvide que está en un lenguaje de programación y tiene otras herramientas a su disposición. En lugar de crear una expresión regular compleja, a menudo es más fácil escribir una serie de expresiones regulares más simples. Si te quedas atascado tratando de crear una expresión regular única que resuelva tu problema, da un paso atrás y piensa si podrías dividir el problema en partes más pequeñas, resolviendo cada desafío antes de pasar al siguiente.

14.4.1 Detectar coincidencias
Para determinar si un vector de caracteres coincide con un patrón, use str_detect(). Devuelve un vector lógico con la misma longitud que la entrada:

x <- c("apple", "banana", "pear")
str_detect(x, "e")
#> [1]  TRUE FALSE  TRUE
Recuerde que cuando se utiliza un vector lógico en un contexto numérico, FALSEse convierte en 0 y TRUEse convierte en 1. Que hace sum()y mean()útil si desea responder a preguntas sobre partidos a través de un vector más grande:

# How many common words start with t?
sum(str_detect(words, "^t"))
#> [1] 65
# What proportion of common words end with a vowel?
mean(str_detect(words, "[aeiou]$"))
#> [1] 0.277
Cuando tiene condiciones lógicas complejas (por ejemplo, coincide con aob, pero no conc a menos que d) a menudo es más fácil combinar múltiples str_detect()llamadas con operadores lógicos, en lugar de tratar de crear una única expresión regular. Por ejemplo, aquí hay dos formas de encontrar todas las palabras que no contienen vocales:

# Find all words containing at least one vowel, and negate
no_vowels_1 <- !str_detect(words, "[aeiou]")
# Find all words consisting only of consonants (non-vowels)
no_vowels_2 <- str_detect(words, "^[^aeiou]+$")
identical(no_vowels_1, no_vowels_2)
#> [1] TRUE
Los resultados son idénticos, pero creo que el primer enfoque es significativamente más fácil de entender. Si su expresión regular se vuelve demasiado complicada, intente dividirla en partes más pequeñas, dándole un nombre a cada pieza y luego combinando las piezas con operaciones lógicas.

Un uso común de str_detect()es seleccionar los elementos que coinciden con un patrón. Puede hacer esto con subconjunto lógico o el str_subset()contenedor conveniente :

words[str_detect(words, "x$")]
#> [1] "box" "sex" "six" "tax"
str_subset(words, "x$")
#> [1] "box" "sex" "six" "tax"
Normalmente, sin embargo, sus cadenas serán una columna de un marco de datos, y en su lugar querrá usar el filtro:

df <- tibble(
  word = words, 
  i = seq_along(word)
)
df %>% 
  filter(str_detect(words, "x$"))
#> # A tibble: 4 x 2
#>   word      i
#>   <chr> <int>
#> 1 box     108
#> 2 sex     747
#> 3 six     772
#> 4 tax     841
Una variación str_detect()es str_count(): en lugar de un simple sí o no, te dice cuántas coincidencias hay en una cadena:

x <- c("apple", "banana", "pear")
str_count(x, "a")
#> [1] 1 3 1

# On average, how many vowels per word?
mean(str_count(words, "[aeiou]"))
#> [1] 1.99
Es natural usarlo str_count()con mutate():

df %>% 
  mutate(
    vowels = str_count(word, "[aeiou]"),
    consonants = str_count(word, "[^aeiou]")
  )
#> # A tibble: 980 x 4
#>   word         i vowels consonants
#>   <chr>    <int>  <int>      <int>
#> 1 a            1      1          0
#> 2 able         2      2          2
#> 3 about        3      3          2
#> 4 absolute     4      4          4
#> 5 accept       5      2          4
#> 6 account      6      3          4
#> # ... with 974 more rows
Tenga en cuenta que las coincidencias nunca se superponen. Por ejemplo, en "abababa", ¿cuántas veces "aba"coincidirá el patrón ? Las expresiones regulares dicen dos, no tres:

str_count("abababa", "aba")
#> [1] 2
str_view_all("abababa", "aba")
aba b aba
Tenga en cuenta el uso de str_view_all(). Como pronto aprenderá, muchas funciones de stringr vienen en pares: una función funciona con una sola coincidencia, y la otra funciona con todas las coincidencias. La segunda función tendrá el sufijo _all.

14.4.2 Ejercicios
Para cada uno de los siguientes desafíos, intente resolverlo utilizando una sola expresión regular y una combinación de str_detect()llamadas múltiples .

Encuentra todas las palabras que comienzan o terminan x.

Encuentra todas las palabras que comienzan con una vocal y terminan con una consonante.

¿Hay alguna palabra que contenga al menos una de cada vocal diferente?

¿Qué palabra tiene el mayor número de vocales? ¿Qué palabra tiene la mayor proporción de vocales? (Sugerencia: ¿cuál es el denominador?)

14.4.3 Extraer coincidencias
Para extraer el texto real de una coincidencia, use str_extract(). Para demostrarlo, vamos a necesitar un ejemplo más complicado. Voy a usar las oraciones de Harvard , que fueron diseñadas para probar sistemas VOIP, pero también son útiles para practicar expresiones regulares. Estos se proporcionan en stringr::sentences:

length(sentences)
#> [1] 720
head(sentences)
#> [1] "The birch canoe slid on the smooth planks." 
#> [2] "Glue the sheet to the dark blue background."
#> [3] "It's easy to tell the depth of a well."     
#> [4] "These days a chicken leg is a rare dish."   
#> [5] "Rice is often served in round bowls."       
#> [6] "The juice of lemons makes fine punch."
Imagine que queremos encontrar todas las oraciones que contienen un color. Primero creamos un vector de nombres de colores y luego lo convertimos en una única expresión regular:

colours <- c("red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match
#> [1] "red|orange|yellow|green|blue|purple"
Ahora podemos seleccionar las oraciones que contienen un color, y luego extraer el color para descubrir cuál es:

has_colour <- str_subset(sentences, colour_match)
matches <- str_extract(has_colour, colour_match)
head(matches)
#> [1] "blue" "blue" "red"  "red"  "red"  "blue"
Tenga en cuenta que str_extract()solo extrae la primera coincidencia. Podemos ver eso más fácilmente al seleccionar primero todas las oraciones que tienen más de 1 coincidencia:

more <- sentences[str_count(sentences, colour_match) > 1]
str_view_all(more, colour_match)
Es difícil borrar tinta azul o roja .
La luz verde en el cuadro marrón parpadea en rojo .
El cielo en el oeste está teñido de rojo anaranjado .

str_extract(more, colour_match)
#> [1] "blue"   "green"  "orange"
Este es un patrón común para las funciones de cadena, porque trabajar con una sola coincidencia le permite utilizar estructuras de datos mucho más simples. Para obtener todas las coincidencias, use str_extract_all(). Devuelve una lista:

str_extract_all(more, colour_match)
#> [[1]]
#> [1] "blue" "red" 
#> 
#> [[2]]
#> [1] "green" "red"  
#> 
#> [[3]]
#> [1] "orange" "red"
Aprenderá más sobre listas en listas e iteraciones .

Si usa simplify = TRUE, str_extract_all()devolverá una matriz con coincidencias cortas expandidas a la misma longitud que la más larga:

str_extract_all(more, colour_match, simplify = TRUE)
#>      [,1]     [,2] 
#> [1,] "blue"   "red"
#> [2,] "green"  "red"
#> [3,] "orange" "red"

x <- c("a", "a b", "a b c")
str_extract_all(x, "[a-z]", simplify = TRUE)
#>      [,1] [,2] [,3]
#> [1,] "a"  ""   ""  
#> [2,] "a"  "b"  ""  
#> [3,] "a"  "b"  "c"
14.4.3.1 Ejercicios
En el ejemplo anterior, es posible que haya notado que la expresión regular coincide con "flickered", que no es un color. Modificar la expresión regular para solucionar el problema.

De los datos de las oraciones de Harvard, extrae:

La primera palabra de cada oración
Todas las palabras que terminan en ing.
Todos los plurales
14.4.4 Partidas agrupadas
Anteriormente, en este capítulo, hablamos sobre el uso de paréntesis para aclarar la precedencia y para referencias al momento de la comparación. También puede usar paréntesis para extraer partes de una coincidencia compleja. Por ejemplo, imagina que queremos extraer sustantivos de las oraciones. Como heurística, buscaremos cualquier palabra que venga después de "a" o "the". Definir una "palabra" en una expresión regular es un poco complicado, así que aquí utilizo una aproximación simple: una secuencia de al menos un carácter que no es un espacio.

noun <- "(a|the) ([^ ]+)"

has_noun <- sentences %>%
  str_subset(noun) %>%
  head(10)
has_noun %>% 
  str_extract(noun)
#>  [1] "the smooth" "the sheet"  "the depth"  "a chicken"  "the parked"
#>  [6] "the sun"    "the huge"   "the ball"   "the woman"  "a helps"
str_extract()nos da la coincidencia completa; str_match()da a cada componente individual. En lugar de un vector de caracteres, devuelve una matriz, con una columna para la coincidencia completa seguida de una columna para cada grupo:

has_noun %>% 
  str_match(noun)
#>       [,1]         [,2]  [,3]     
#>  [1,] "the smooth" "the" "smooth" 
#>  [2,] "the sheet"  "the" "sheet"  
#>  [3,] "the depth"  "the" "depth"  
#>  [4,] "a chicken"  "a"   "chicken"
#>  [5,] "the parked" "the" "parked" 
#>  [6,] "the sun"    "the" "sun"    
#>  [7,] "the huge"   "the" "huge"   
#>  [8,] "the ball"   "the" "ball"   
#>  [9,] "the woman"  "the" "woman"  
#> [10,] "a helps"    "a"   "helps"
(Como era de esperar, nuestra heurística para detectar sustantivos es pobre, y también capta adjetivos como suaves y estacionados).

Si sus datos están en un tibble, a menudo es más fácil de usar tidyr::extract(). Funciona de la misma manera str_match()pero requiere que nombre las coincidencias, que luego se colocan en columnas nuevas:

tibble(sentence = sentences) %>% 
  tidyr::extract(
    sentence, c("article", "noun"), "(a|the) ([^ ]+)", 
    remove = FALSE
  )
#> # A tibble: 720 x 3
#>   sentence                                    article noun   
#>   <chr>                                       <chr>   <chr>  
#> 1 The birch canoe slid on the smooth planks.  the     smooth 
#> 2 Glue the sheet to the dark blue background. the     sheet  
#> 3 It's easy to tell the depth of a well.      the     depth  
#> 4 These days a chicken leg is a rare dish.    a       chicken
#> 5 Rice is often served in round bowls.        <NA>    <NA>   
#> 6 The juice of lemons makes fine punch.       <NA>    <NA>   
#> # ... with 714 more rows
Por ejemplo str_extract(), si quieres todas las coincidencias para cada cadena, necesitarás str_match_all().

14.4.4.1 Ejercicios
Encuentra todas las palabras que vienen después de un "número" como "uno", "dos", "tres", etc. Saca el número y la palabra.

Encuentra todas las contracciones. Separe las piezas antes y después del apóstrofo.

14.4.5 Reemplazar partidos
str_replace()y le str_replace_all()permite reemplazar coincidencias con nuevas cadenas. El uso más simple es reemplazar un patrón con una cadena fija:

x <- c("apple", "pear", "banana")
str_replace(x, "[aeiou]", "-")
#> [1] "-pple"  "p-ar"   "b-nana"
str_replace_all(x, "[aeiou]", "-")
#> [1] "-ppl-"  "p--r"   "b-n-n-"
Con str_replace_all()usted puede realizar reemplazos múltiples mediante el suministro de un vector nombrado:

x <- c("1 house", "2 cars", "3 people")
str_replace_all(x, c("1" = "one", "2" = "two", "3" = "three"))
#> [1] "one house"    "two cars"     "three people"
En lugar de reemplazar con una cadena fija, puede usar referencias para insertar componentes de la coincidencia. En el siguiente código, cambio el orden de la segunda y tercera palabras.

sentences %>% 
  str_replace("([^ ]+) ([^ ]+) ([^ ]+)", "\\1 \\3 \\2") %>% 
  head(5)
#> [1] "The canoe birch slid on the smooth planks." 
#> [2] "Glue sheet the to the dark blue background."
#> [3] "It's to easy tell the depth of a well."     
#> [4] "These a days chicken leg is a rare dish."   
#> [5] "Rice often is served in round bowls."
14.4.5.1 Ejercicios
Reemplace todas las barras diagonales en una cadena con barras diagonales inversas.

Implemente una versión simple de str_to_lower()usar replace_all().

Cambiar la primera y la última letra en words. ¿Cuáles de esas cuerdas son todavía palabras?

14.4.6 División
Úselo str_split()para dividir una cuerda en pedazos. Por ejemplo, podríamos dividir oraciones en palabras:

sentences %>%
  head(5) %>% 
  str_split(" ")
#> [[1]]
#> [1] "The"     "birch"   "canoe"   "slid"    "on"      "the"     "smooth" 
#> [8] "planks."
#> 
#> [[2]]
#> [1] "Glue"        "the"         "sheet"       "to"          "the"        
#> [6] "dark"        "blue"        "background."
#> 
#> [[3]]
#> [1] "It's"  "easy"  "to"    "tell"  "the"   "depth" "of"    "a"     "well."
#> 
#> [[4]]
#> [1] "These"   "days"    "a"       "chicken" "leg"     "is"      "a"      
#> [8] "rare"    "dish."  
#> 
#> [[5]]
#> [1] "Rice"   "is"     "often"  "served" "in"     "round"  "bowls."
Debido a que cada componente puede contener un número diferente de piezas, esto devuelve una lista. Si está trabajando con un vector de longitud 1, lo más fácil es extraer el primer elemento de la lista:

"a|b|c|d" %>% 
  str_split("\\|") %>% 
  .[[1]]
#> [1] "a" "b" "c" "d"
De lo contrario, al igual que las otras funciones de cadena que devuelven una lista, puede usar simplify = TRUEpara devolver una matriz:

sentences %>%
  head(5) %>% 
  str_split(" ", simplify = TRUE)
#>      [,1]    [,2]    [,3]    [,4]      [,5]  [,6]    [,7]    
#> [1,] "The"   "birch" "canoe" "slid"    "on"  "the"   "smooth"
#> [2,] "Glue"  "the"   "sheet" "to"      "the" "dark"  "blue"  
#> [3,] "It's"  "easy"  "to"    "tell"    "the" "depth" "of"    
#> [4,] "These" "days"  "a"     "chicken" "leg" "is"    "a"     
#> [5,] "Rice"  "is"    "often" "served"  "in"  "round" "bowls."
#>      [,8]          [,9]   
#> [1,] "planks."     ""     
#> [2,] "background." ""     
#> [3,] "a"           "well."
#> [4,] "rare"        "dish."
#> [5,] ""            ""
También puede solicitar un número máximo de piezas:

fields <- c("Name: Hadley", "Country: NZ", "Age: 35")
fields %>% str_split(": ", n = 2, simplify = TRUE)
#>      [,1]      [,2]    
#> [1,] "Name"    "Hadley"
#> [2,] "Country" "NZ"    
#> [3,] "Age"     "35"
En lugar de dividir cadenas por patrones, también puede dividir por carácter, línea, oración y palabra boundary()s:

x <- "This is a sentence.  This is another sentence."
str_view_all(x, boundary("word"))
Esta es una oración . Esta es otra oración .

str_split(x, " ")[[1]]
#> [1] "This"      "is"        "a"         "sentence." ""          "This"     
#> [7] "is"        "another"   "sentence."
str_split(x, boundary("word"))[[1]]
#> [1] "This"     "is"       "a"        "sentence" "This"     "is"      
#> [7] "another"  "sentence"
14.4.6.1 Ejercicios
Divide una cadena como "apples, pears, and bananas"en componentes individuales.

¿Por qué es mejor dividirse por boundary("word")más " "?

¿Qué hace la división con una cadena vacía ( "")? Experimenta y luego lee la documentación.

14.4.7 Buscar coincidencias
str_locate()y le str_locate_all()dará las posiciones inicial y final de cada partido. Estos son particularmente útiles cuando ninguna de las otras funciones hace exactamente lo que usted desea. Puede usar str_locate()para encontrar el patrón coincidente, str_sub()para extraerlo y / o modificarlo.

14.5 Otros tipos de patrones
Cuando utiliza un patrón que es una cadena, se envuelve automáticamente en una llamada a regex():

# The regular call:
str_view(fruit, "nana")
# Is shorthand for
str_view(fruit, regex("nana"))
Puede usar los otros argumentos de regex()para controlar los detalles de la coincidencia:

ignore_case = TRUEpermite que los personajes coincidan con sus mayúsculas o minúsculas. Esto siempre usa la configuración regional actual.

bananas <- c("banana", "Banana", "BANANA")
str_view(bananas, "banana")
plátano
Plátano
PLÁTANO
str_view(bananas, regex("banana", ignore_case = TRUE))
plátano
Plátano
PLÁTANO
multiline = TRUEpermite ^y hace $coincidir el inicio y el final de cada línea en lugar del inicio y el final de la cadena completa.

x <- "Line 1\nLine 2\nLine 3"
str_extract_all(x, "^Line")[[1]]
#> [1] "Line"
str_extract_all(x, regex("^Line", multiline = TRUE))[[1]]
#> [1] "Line" "Line" "Line"
comments = TRUEle permite usar comentarios y espacios en blanco para hacer que las expresiones regulares complejas sean más comprensibles. Los espacios son ignorados, como lo es todo después #. Para que coincida con un espacio literal, que necesita para escapar de ella: "\\ ".

phone <- regex("
  \\(?     # optional opening parens
  (\\d{3}) # area code
  [) -]?   # optional closing parens, space, or dash
  (\\d{3}) # another three numbers
  [ -]?    # optional space or dash
  (\\d{3}) # three more numbers
  ", comments = TRUE)

str_match("514-791-8141", phone)
#>      [,1]          [,2]  [,3]  [,4] 
#> [1,] "514-791-814" "514" "791" "814"
dotall = TRUEpermite .para que coincida con todo, incluso \n.

Hay otras tres funciones que puede usar en lugar de regex():

fixed(): coincide exactamente con la secuencia de bytes especificada. Ignora todas las expresiones regulares especiales y opera a un nivel muy bajo. Esto le permite evitar el escape complejo y puede ser mucho más rápido que las expresiones regulares. El siguiente microbenchmark muestra que es aproximadamente 3 veces más rápido en un ejemplo simple.

microbenchmark::microbenchmark(
  fixed = str_detect(sentences, fixed("the")),
  regex = str_detect(sentences, "the"),
  times = 20
)
#> Unit: microseconds
#>   expr min  lq mean median  uq max neval
#>  fixed 104 110  129    114 125 360    20
#>  regex 299 306  325    308 326 579    20
Tenga cuidado fixed()con el uso de datos que no sean en inglés. Es problemático porque a menudo hay múltiples formas de representar al mismo personaje. Por ejemplo, hay dos formas de definir "á": como un solo carácter o como una "a" más un acento:

a1 <- "\u00e1"
a2 <- "a\u0301"
c(a1, a2)
#> [1] "á" "á"
a1 == a2
#> [1] FALSE
Representan de forma idéntica, pero debido a que están definidos de manera diferente, fixed()no encuentran una coincidencia. En cambio, puede usar coll(), definido a continuación, para respetar las reglas de comparación de caracteres humanos:

str_detect(a1, fixed(a2))
#> [1] FALSE
str_detect(a1, coll(a2))
#> [1] TRUE
coll(): comparar cadenas usando las reglas de coll ación estándar . Esto es útil para hacer coincidencias insensibles a mayúsculas y minúsculas. Tenga en cuenta que coll()toma un localeparámetro que controla qué reglas se usan para comparar caracteres. Desafortunadamente, ¡diferentes partes del mundo usan diferentes reglas!

# That means you also need to be aware of the difference
# when doing case insensitive matches:
i <- c("I", "İ", "i", "ı")
i
#> [1] "I" "İ" "i" "ı"

str_subset(i, coll("i", ignore_case = TRUE))
#> [1] "I" "i"
str_subset(i, coll("i", ignore_case = TRUE, locale = "tr"))
#> [1] "İ" "i"
Tanto fixed()y regex()tienen ignore_caseargumentos, pero no permiten que usted pueda elegir la configuración regional: siempre utilizan la configuración regional predeterminada. Puedes ver lo que es con el siguiente código; más en stringi después.

stringi::stri_locale_info()
#> $Language
#> [1] "en"
#> 
#> $Country
#> [1] "US"
#> 
#> $Variant
#> [1] ""
#> 
#> $Name
#> [1] "en_US"
La desventaja de coll()es la velocidad; porque las reglas para reconocer qué caracteres son los mismos son complicadas, coll()es relativamente lento en comparación con regex()y fixed().

Como vio con str_split()usted puede usar boundary()para unir límites. También puede usarlo con las otras funciones:

x <- "This is a sentence."
str_view_all(x, boundary("word"))
Esta es una oración .
str_extract_all(x, boundary("word"))
#> [[1]]
#> [1] "This"     "is"       "a"        "sentence"
14.5.1 Ejercicios
¿Cómo encontrar todas las cadenas que contengan \la regex() frente con fixed()?

¿Cuáles son las cinco palabras más comunes en sentences?

14.6 Otros usos de expresiones regulares
Hay dos funciones útiles en la base R que también usan expresiones regulares:

apropos()busca todos los objetos disponibles del entorno global. Esto es útil si no puede recordar el nombre de la función.

apropos("replace")
#> [1] "%+replace%"       "replace"          "replace_na"      
#> [4] "setReplaceMethod" "str_replace"      "str_replace_all" 
#> [7] "str_replace_na"   "theme_replace"
dir()lista todos los archivos en un directorio. El patternargumento toma una expresión regular y solo devuelve nombres de archivos que coinciden con el patrón. Por ejemplo, puede encontrar todos los archivos R Markdown en el directorio actual con:

head(dir(pattern = "\\.Rmd$"))
#> [1] "communicate-plots.Rmd" "communicate.Rmd"       "datetimes.Rmd"        
#> [4] "EDA.Rmd"               "explore.Rmd"           "factors.Rmd"
(Si te sientes más cómodo con "globs" *.Rmd, puedes convertirlos a expresiones regulares con glob2rx()):

14.7 stringi
stringr está construido sobre el paquete stringi . stringr es útil cuando estás aprendiendo porque expone un conjunto mínimo de funciones, que se han seleccionado cuidadosamente para manejar las funciones de manipulación de cadenas más comunes. stringi, por otro lado, está diseñado para ser completo. Contiene casi todas las funciones que pueda necesitar: stringi tiene 234 funciones para stringr's 46.

Si te encuentras luchando por hacer algo en stringr, vale la pena echarle un vistazo a stringi. Los paquetes funcionan de manera muy similar, por lo que debería poder traducir el conocimiento de su secuenciador de forma natural. La principal diferencia es el prefijo: str_vs stri_.

14.7.1 Ejercicios
Encuentra las funciones de stringi que:

Cuenta el número de palabras.
Encuentra cadenas duplicadas.
Genera texto aleatorio
¿Cómo controlas el lenguaje que stri_sort()usa para clasificar?

***

15 factores
15.1 Introducción
En R, los factores se usan para trabajar con variables categóricas, variables que tienen un conjunto fijo y conocido de valores posibles. También son útiles cuando quiere mostrar vectores de caracteres en un orden no alfabético.

Históricamente, los factores eran mucho más fáciles de trabajar que los personajes. Como resultado, muchas de las funciones en la base R automáticamente convierten los caracteres en factores. Esto significa que los factores a menudo surgen en lugares donde no son realmente útiles. Afortunadamente, no necesita preocuparse por eso en el tidyverse, y puede enfocarse en situaciones donde los factores son realmente útiles.

15.1.1 prerrequisitos
Para trabajar con factores, usaremos el forcats paquete, que proporciona herramientas para hacer frente a gato variables de egorical (y es anagrama de factores!). Proporciona una amplia gama de ayudantes para trabajar con factores. Forcats no es parte del tidyverse central, por lo que debemos cargarlo explícitamente.

library(tidyverse)
library(forcats)
15.1.2 Aprender más
Si desea obtener más información acerca de los factores, recomiendo la lectura Amelia McNamara y papel de Nicholas Horton, Wrangling datos categóricos en I . Este documento presenta parte de la historia discutida en stringsAsFactors: Una biografía no autorizada y stringsAsFactors = <suspiro> , y compara los enfoques ordenados a los datos categóricos descritos en este libro con los métodos de base R. Una primera versión del documento ayuda a motivar y ampliar el paquete de forcats; gracias Amelia y Nick!

15.2 Creando factores
Imagine que tiene una variable que registra el mes:

x1 <- c("Dec", "Apr", "Jan", "Mar")
Usar una cadena para registrar esta variable tiene dos problemas:

Solo hay doce meses posibles, y no hay nada que te salve de los errores tipográficos:

x2 <- c("Dec", "Apr", "Jam", "Mar")
No ordena de una manera útil:

sort(x1)
#> [1] "Apr" "Dec" "Jan" "Mar"
Puede solucionar ambos problemas con un factor. Para crear un factor, debe comenzar creando una lista de los niveles válidos :

month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
Ahora puedes crear un factor:

y1 <- factor(x1, levels = month_levels)
y1
#> [1] Dec Apr Jan Mar
#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
sort(y1)
#> [1] Jan Mar Apr Dec
#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
Y cualquier valor que no esté en el conjunto se convertirá silenciosamente a NA:

y2 <- factor(x2, levels = month_levels)
y2
#> [1] Dec  Apr  <NA> Mar 
#> Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec
Si quieres una advertencia, puedes usar readr::parse_factor():

y2 <- parse_factor(x2, levels = month_levels)
#> Warning: 1 parsing failure.
#> row # A tibble: 1 x 4 col     row   col expected           actual expected   <int> <int> <chr>              <chr>  actual 1     3    NA value in level set Jam
Si omite los niveles, se tomarán de los datos en orden alfabético:

factor(x1)
#> [1] Dec Apr Jan Mar
#> Levels: Apr Dec Jan Mar
A veces preferiría que el orden de los niveles coincida con el orden de la primera aparición en los datos. Puede hacerlo al crear el factor estableciendo niveles a unique(x), o después del hecho, con fct_inorder():

f1 <- factor(x1, levels = unique(x1))
f1
#> [1] Dec Apr Jan Mar
#> Levels: Dec Apr Jan Mar

f2 <- x1 %>% factor() %>% fct_inorder()
f2
#> [1] Dec Apr Jan Mar
#> Levels: Dec Apr Jan Mar
Si alguna vez necesita acceder al conjunto de niveles válidos directamente, puede hacerlo con levels():

levels(f2)
#> [1] "Dec" "Apr" "Jan" "Mar"
15.3 Encuesta social general
Para el resto de este capítulo, nos enfocaremos en forcats::gss_cat. Es una muestra de datos de la Encuesta Social General , que es una encuesta de larga data realizada en EE. UU. Por la organización de investigación independiente NORC de la Universidad de Chicago. La encuesta tiene miles de preguntas, por lo gss_catque he seleccionado algunas que ilustrarán algunos desafíos comunes que encontrará al trabajar con factores.

gss_cat
#> # A tibble: 21,483 x 9
#>    year marital         age race  rincome  partyid   relig  denom  tvhours
#>   <int> <fct>         <int> <fct> <fct>    <fct>     <fct>  <fct>    <int>
#> 1  2000 Never married    26 White $8000 t… Ind,near… Prote… South…      12
#> 2  2000 Divorced         48 White $8000 t… Not str … Prote… Bapti…      NA
#> 3  2000 Widowed          67 White Not app… Independ… Prote… No de…       2
#> 4  2000 Never married    39 White Not app… Ind,near… Ortho… Not a…       4
#> 5  2000 Divorced         25 White Not app… Not str … None   Not a…       1
#> 6  2000 Married          25 White $20000 … Strong d… Prote… South…      NA
#> # ... with 2.148e+04 more rows
(Recuerde, dado que este conjunto de datos es proporcionado por un paquete, puede obtener más información sobre las variables con ?gss_cat.)

Cuando los factores se almacenan en un tibble, no puedes ver sus niveles tan fácilmente. Una forma de verlos es con count():

gss_cat %>%
  count(race)
#> # A tibble: 3 x 2
#>   race      n
#>   <fct> <int>
#> 1 Other  1959
#> 2 Black  3129
#> 3 White 16395
O con un gráfico de barras:

ggplot(gss_cat, aes(race)) +
  geom_bar()


Por defecto, ggplot2 soltará niveles que no tienen ningún valor. Puede obligarlos a mostrar con:

ggplot(gss_cat, aes(race)) +
  geom_bar() +
  scale_x_discrete(drop = FALSE)


Estos niveles representan valores válidos que simplemente no ocurrieron en este conjunto de datos. Desafortunadamente, dplyr todavía no tiene una dropopción, pero lo hará en el futuro.

Al trabajar con factores, las dos operaciones más comunes cambian el orden de los niveles y cambian los valores de los niveles. Esas operaciones se describen en las siguientes secciones.

15.3.1 Ejercicio
Explore la distribución de rincome(ingreso reportado). ¿Qué hace que el gráfico de barras predeterminado sea difícil de entender? ¿Cómo podrías mejorar la trama?

¿Cuál es el más común religen esta encuesta? ¿Cuál es el más común partyid?

¿ religA qué se aplica denom(denominación)? ¿Cómo puedes averiguarlo con una mesa? ¿Cómo puedes averiguarlo con una visualización?

15.4 Modificación de orden de los factores
A menudo es útil cambiar el orden de los niveles de los factores en una visualización. Por ejemplo, imagina que quieres explorar el promedio de horas dedicadas a ver televisión por día en diferentes religiones:

relig_summary <- gss_cat %>%
  group_by(relig) %>%
  summarise(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(relig_summary, aes(tvhours, relig)) + geom_point()


Es difícil interpretar esta trama porque no hay un patrón general. Podemos mejorarlo reordenando los niveles de religuso fct_reorder(). fct_reorder()toma tres argumentos:

f, el factor cuyos niveles quieres modificar
x, un vector numérico que desea usar para reordenar los niveles.
Opcionalmente, fununa función que se usa si hay múltiples valores de xpara cada valor de f. El valor predeterminado es median.
ggplot(relig_summary, aes(tvhours, fct_reorder(relig, tvhours))) +
  geom_point()


Reordenar la religión hace que sea mucho más fácil ver que las personas de la categoría "No sé" miran mucha más televisión, y el Hinduismo y otras religiones orientales miran mucho menos.

A medida que comienzas a hacer transformaciones más complicadas, te recomiendo moverlas de aes()un mutate()paso por separado . Por ejemplo, podría reescribir la trama anterior como:

relig_summary %>%
  mutate(relig = fct_reorder(relig, tvhours)) %>%
  ggplot(aes(tvhours, relig)) +
    geom_point()
¿Qué pasa si creamos una trama similar mirando cómo varía la edad promedio a través del nivel de ingresos reportados?

rincome_summary <- gss_cat %>%
  group_by(rincome) %>%
  summarise(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(rincome_summary, aes(age, fct_reorder(rincome, age))) + geom_point()


¡Aquí, reordenar arbitrariamente los niveles no es una buena idea! Eso es porque rincomeya tiene un orden de principios con el que no deberíamos meternos. Reserva fct_reorder()para factores cuyos niveles se ordenan arbitrariamente.

Sin embargo, tiene sentido tirar "No aplicable" al frente con los otros niveles especiales. Puede usar fct_relevel(). Toma un factor, fy luego cualquier cantidad de niveles que desee mover al frente de la línea.

ggplot(rincome_summary, aes(age, fct_relevel(rincome, "Not applicable"))) +
  geom_point()


¿Por qué crees que la edad promedio para "No aplicable" es tan alta?

Otro tipo de reordenamiento es útil cuando se colorean las líneas en un diagrama. fct_reorder2()reordena el factor por los yvalores asociados con los xvalores más grandes . Esto hace que la trama sea más fácil de leer porque los colores de la línea se alinean con la leyenda.

by_age <- gss_cat %>%
  filter(!is.na(age)) %>%
  count(age, marital) %>%
  group_by(age) %>%
  mutate(prop = n / sum(n))

ggplot(by_age, aes(age, prop, colour = marital)) +
  geom_line(na.rm = TRUE)

ggplot(by_age, aes(age, prop, colour = fct_reorder2(marital, age, prop))) +
  geom_line() +
  labs(colour = "marital")


Finalmente, para gráficos de barra, puede usar fct_infreq()para ordenar niveles en frecuencia creciente: este es el tipo más simple de reordenamiento porque no necesita ninguna variable adicional. Es posible que desee combinar con fct_rev().

gss_cat %>%
  mutate(marital = marital %>% fct_infreq() %>% fct_rev()) %>%
  ggplot(aes(marital)) +
    geom_bar()


15.4.1 Ejercicios
Hay algunos números sospechosamente altos en tvhours. ¿Es el medio un buen resumen?

Para cada factor, gss_catidentifique si el orden de los niveles es arbitrario o de principios.

¿Por qué mover "No aplicable" al frente de los niveles lo mueve al final de la gráfica?

15.5 Modificación de niveles de factores
Más poderoso que cambiar las órdenes de los niveles es cambiar sus valores. Esto le permite aclarar las etiquetas para su publicación y los niveles de contracción para las pantallas de alto nivel. La herramienta más general y poderosa es fct_recode(). Le permite recodificar o cambiar el valor de cada nivel. Por ejemplo, tome el gss_cat$partyid:

gss_cat %>% count(partyid)
#> # A tibble: 10 x 2
#>   partyid                n
#>   <fct>              <int>
#> 1 No answer            154
#> 2 Don't know             1
#> 3 Other party          393
#> 4 Strong republican   2314
#> 5 Not str republican  3032
#> 6 Ind,near rep        1791
#> # ... with 4 more rows
Los niveles son escuetos e inconsistentes. Vamos a ajustarlos para que sean más largos y usar una construcción paralela.

gss_cat %>%
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat"
  )) %>%
  count(partyid)
#> # A tibble: 10 x 2
#>   partyid                   n
#>   <fct>                 <int>
#> 1 No answer               154
#> 2 Don't know                1
#> 3 Other party             393
#> 4 Republican, strong     2314
#> 5 Republican, weak       3032
#> 6 Independent, near rep  1791
#> # ... with 4 more rows
fct_recode() dejará los niveles que no se mencionan explícitamente tal como están, y le advertirá si se refiere accidentalmente a un nivel que no existe.

Para combinar grupos, puede asignar múltiples niveles antiguos al mismo nivel nuevo:

gss_cat %>%
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat",
    "Other"                 = "No answer",
    "Other"                 = "Don't know",
    "Other"                 = "Other party"
  )) %>%
  count(partyid)
#> # A tibble: 8 x 2
#>   partyid                   n
#>   <fct>                 <int>
#> 1 Other                   548
#> 2 Republican, strong     2314
#> 3 Republican, weak       3032
#> 4 Independent, near rep  1791
#> 5 Independent            4119
#> 6 Independent, near dem  2499
#> # ... with 2 more rows
Debe usar esta técnica con cuidado: si agrupa categorías que son realmente diferentes, terminará con resultados engañosos.

Si quiere colapsar muchos niveles, fct_collapse()es una variante útil de fct_recode(). Para cada nueva variable, puede proporcionar un vector de niveles antiguos:

gss_cat %>%
  mutate(partyid = fct_collapse(partyid,
    other = c("No answer", "Don't know", "Other party"),
    rep = c("Strong republican", "Not str republican"),
    ind = c("Ind,near rep", "Independent", "Ind,near dem"),
    dem = c("Not str democrat", "Strong democrat")
  )) %>%
  count(partyid)
#> # A tibble: 4 x 2
#>   partyid     n
#>   <fct>   <int>
#> 1 other     548
#> 2 rep      5346
#> 3 ind      8409
#> 4 dem      7180
A veces solo quieres agrupar a todos los grupos pequeños para simplificar un diagrama o una tabla. Ese es el trabajo de fct_lump():

gss_cat %>%
  mutate(relig = fct_lump(relig)) %>%
  count(relig)
#> # A tibble: 2 x 2
#>   relig          n
#>   <fct>      <int>
#> 1 Protestant 10846
#> 2 Other      10637
El comportamiento predeterminado es agrupar progresivamente los grupos más pequeños, asegurando que el agregado sigue siendo el grupo más pequeño. En este caso, no es muy útil: es cierto que la mayoría de los estadounidenses en esta encuesta son protestantes, pero es probable que hayamos colapsado.

En cambio, podemos usar el nparámetro para especificar cuántos grupos (excluyendo otros) queremos mantener:

gss_cat %>%
  mutate(relig = fct_lump(relig, n = 10)) %>%
  count(relig, sort = TRUE) %>%
  print(n = Inf)
#> # A tibble: 10 x 2
#>    relig                       n
#>    <fct>                   <int>
#>  1 Protestant              10846
#>  2 Catholic                 5124
#>  3 None                     3523
#>  4 Christian                 689
#>  5 Other                     458
#>  6 Jewish                    388
#>  7 Buddhism                  147
#>  8 Inter-nondenominational   109
#>  9 Moslem/islam              104
#> 10 Orthodox-christian         95
15.5.1 Ejercicios
¿Cómo han cambiado con el tiempo las proporciones de personas que se identifican como demócratas, republicanos e independientes?

¿Cómo podría colapsar rincomeen un pequeño conjunto de categorías?

***

16 Fechas y horarios
16.1 Introducción
Este capítulo le mostrará cómo trabajar con fechas y horas en R. A primera vista, las fechas y las horas parecen simples. Los usas todo el tiempo en tu vida normal, y no parecen causar mucha confusión. Sin embargo, cuanto más aprendes sobre fechas y horarios, más complicados parecen obtenerlos. Para calentar, pruebe estas tres preguntas aparentemente simples:

¿Todos los años tienen 365 días?
¿Todos los días tienen 24 horas?
¿Cada minuto tiene 60 segundos?
Estoy seguro de que sabe que no todos los años tiene 365 días, pero ¿conoce la regla completa para determinar si un año es bisiesto? (Tiene tres partes). Es posible que haya recordado que muchas partes del mundo usan el horario de verano (DST), por lo que algunos días tienen 23 horas y otros tienen 25. Es posible que no sepa que algunos minutos tienen 61 segundos porque de vez en cuando se agregan segundos intercalares porque la rotación de la Tierra se está desacelerando gradualmente.

Las fechas y los tiempos son difíciles porque tienen que conciliar dos fenómenos físicos (la rotación de la Tierra y su órbita alrededor del sol) con una gran cantidad de fenómenos geopolíticos que incluyen meses, zonas horarias y horario de verano. Este capítulo no le enseñará hasta el último detalle sobre fechas y horarios, pero le dará una base sólida de habilidades prácticas que lo ayudarán con los desafíos comunes de análisis de datos.

16.1.1 prerrequisitos
Este capítulo se centrará en el paquete lubridate , que facilita el trabajo con fechas y horas en R. lubridate no forma parte de tidyverse central porque solo lo necesita cuando trabaja con fechas / horas. También necesitaremos nycflights13 para datos de práctica.

library(tidyverse)

library(lubridate)
library(nycflights13)
16.2 Creación de fecha / hora
Hay tres tipos de datos de fecha / hora que se refieren a un instante en el tiempo:

A la fecha . Tibbles imprime esto como <date>.

Un tiempo dentro de un día. Tibbles imprime esto como <time>.

Una fecha-hora es una fecha más una hora: identifica de manera única un instante en el tiempo (generalmente al segundo más cercano). Tibbles imprime esto como <dttm>. En otra parte de R estos se llaman POSIXct, pero no creo que sea un nombre muy útil.

En este capítulo solo nos enfocaremos en fechas y fechas ya que R no tiene una clase nativa para almacenar tiempos. Si necesita uno, puede usar el paquete hms .

Siempre debe usar el tipo de datos más simple posible que funcione para sus necesidades. Eso significa que si puede usar una fecha en lugar de una fecha, debería hacerlo. Los horarios son sustancialmente más complicados debido a la necesidad de manejar zonas horarias, que volveremos al final del capítulo.

Para obtener la fecha actual o la fecha y hora, puede usar today()o now():

today()
#> [1] "2018-06-21"
now()
#> [1] "2018-06-21 03:12:40 UTC"
De lo contrario, hay tres formas en las que es probable que cree una fecha / hora:

De una cadena.
A partir de componentes individuales de fecha y hora.
Desde un objeto de fecha / hora existente.
Funcionan de la siguiente manera.

16.2.1 De cadenas
Los datos de fecha / hora a menudo vienen como cadenas. Has visto un enfoque para analizar cadenas de caracteres en fechas-fechas en el horario . Otro enfoque es usar los ayudantes provistos por lubridate. Automáticamente resuelven el formato una vez que especifica el orden del componente. Para usarlos, identifique el orden en que aparecen el año, el mes y el día en sus fechas, luego organice "y", "m" y "d" en el mismo orden. Eso le da el nombre de la función lubridate que analizará su fecha. Por ejemplo:

ymd("2017-01-31")
#> [1] "2017-01-31"
mdy("January 31st, 2017")
#> [1] "2017-01-31"
dmy("31-Jan-2017")
#> [1] "2017-01-31"
Estas funciones también toman números sin comillas. Esta es la forma más concisa de crear un único objeto de fecha / hora, como puede ser necesario al filtrar datos de fecha / hora. ymd()es corto e inequívoco:

ymd(20170131)
#> [1] "2017-01-31"
ymd()y amigos crean fechas. Para crear una fecha y hora, agregue un guión bajo y una o más de "h", "m" y "s" al nombre de la función de análisis sintáctico:

ymd_hms("2017-01-31 20:11:59")
#> [1] "2017-01-31 20:11:59 UTC"
mdy_hm("01/31/2017 08:01")
#> [1] "2017-01-31 08:01:00 UTC"
También puede forzar la creación de una fecha y hora a partir de una fecha suministrando una zona horaria:

ymd(20170131, tz = "UTC")
#> [1] "2017-01-31 UTC"
16.2.2 De componentes individuales
En lugar de una sola cadena, a veces tendrá los componentes individuales de la fecha y hora distribuidos en varias columnas. Esto es lo que tenemos en los datos de vuelos:

flights %>% 
  select(year, month, day, hour, minute)
#> # A tibble: 336,776 x 5
#>    year month   day  hour minute
#>   <int> <int> <int> <dbl>  <dbl>
#> 1  2013     1     1     5     15
#> 2  2013     1     1     5     29
#> 3  2013     1     1     5     40
#> 4  2013     1     1     5     45
#> 5  2013     1     1     6      0
#> 6  2013     1     1     5     58
#> # ... with 3.368e+05 more rows
Para crear una fecha / hora a partir de este tipo de entrada, utilícela make_date()para fechas o make_datetime()fechas:

flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(departure = make_datetime(year, month, day, hour, minute))
#> # A tibble: 336,776 x 6
#>    year month   day  hour minute departure          
#>   <int> <int> <int> <dbl>  <dbl> <dttm>             
#> 1  2013     1     1     5     15 2013-01-01 05:15:00
#> 2  2013     1     1     5     29 2013-01-01 05:29:00
#> 3  2013     1     1     5     40 2013-01-01 05:40:00
#> 4  2013     1     1     5     45 2013-01-01 05:45:00
#> 5  2013     1     1     6      0 2013-01-01 06:00:00
#> 6  2013     1     1     5     58 2013-01-01 05:58:00
#> # ... with 3.368e+05 more rows
Hagamos lo mismo para cada una de las cuatro columnas de tiempo en flights. Los tiempos están representados en un formato ligeramente extraño, por lo que usamos la aritmética de módulo para extraer los componentes de hora y minuto. Una vez que he creado las variables de fecha y hora, me concentro en las variables que exploraremos en el resto del capítulo.

make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights %>% 
  filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) %>% 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
#> # A tibble: 328,063 x 9
#>   origin dest  dep_delay arr_delay dep_time            sched_dep_time     
#>   <chr>  <chr>     <dbl>     <dbl> <dttm>              <dttm>             
#> 1 EWR    IAH           2        11 2013-01-01 05:17:00 2013-01-01 05:15:00
#> 2 LGA    IAH           4        20 2013-01-01 05:33:00 2013-01-01 05:29:00
#> 3 JFK    MIA           2        33 2013-01-01 05:42:00 2013-01-01 05:40:00
#> 4 JFK    BQN          -1       -18 2013-01-01 05:44:00 2013-01-01 05:45:00
#> 5 LGA    ATL          -6       -25 2013-01-01 05:54:00 2013-01-01 06:00:00
#> 6 EWR    ORD          -4        12 2013-01-01 05:54:00 2013-01-01 05:58:00
#> # ... with 3.281e+05 more rows, and 3 more variables: arr_time <dttm>,
#> #   sched_arr_time <dttm>, air_time <dbl>
Con estos datos, puedo visualizar la distribución de los horarios de salida a lo largo del año:

flights_dt %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 seconds = 1 day


O en un solo día:

flights_dt %>% 
  filter(dep_time < ymd(20130102)) %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes


Tenga en cuenta que cuando utiliza fechas y horas en un contexto numérico (como en un histograma), 1 significa 1 segundo, por lo que un ancho de 86400 equivale a un día. Para las fechas, 1 significa 1 día.

16.2.3 De otros tipos
Es posible que desee cambiar entre una fecha y una fecha. Ese es el trabajo de as_datetime()y as_date():

as_datetime(today())
#> [1] "2018-06-21 UTC"
as_date(now())
#> [1] "2018-06-21"
Algunas veces obtendrás fecha / hora como compensaciones numéricas de la "Época Unix", 1970-01-01. Si el desplazamiento está en segundos, use as_datetime(); si es en días, use as_date().

as_datetime(60 * 60 * 10)
#> [1] "1970-01-01 10:00:00 UTC"
as_date(365 * 10 + 2)
#> [1] "1980-01-01"
16.2.4 Ejercicios
¿Qué sucede si analiza una cadena que contiene fechas no válidas?

ymd(c("2010-10-10", "bananas"))
¿Qué hace el tzoneargumento para today()hacer? ¿Por qué es importante?

Use la función lubridate apropiada para analizar cada una de las siguientes fechas:

d1 <- "January 1, 2010"
d2 <- "2015-Mar-07"
d3 <- "06-Jun-2017"
d4 <- c("August 19 (2015)", "July 1 (2015)")
d5 <- "12/30/14" # Dec 30, 2014
16.3 Componentes de fecha y hora
Ahora que sabe cómo obtener datos de fecha y hora en las estructuras de datos de fecha y hora de R, exploremos qué puede hacer con ellos. Esta sección se centrará en las funciones de acceso que le permiten obtener y configurar componentes individuales. La siguiente sección verá cómo funciona la aritmética con los tiempos de fecha.

16.3.1 Obteniendo componentes
Puede sacar las piezas individuales de la fecha con las funciones de acceso year(), month(), mday()(día del mes), yday()(los días del año), wday()(día de la semana), hour(), minute(), y second().

datetime <- ymd_hms("2016-07-08 12:34:56")

year(datetime)
#> [1] 2016
month(datetime)
#> [1] 7
mday(datetime)
#> [1] 8

yday(datetime)
#> [1] 190
wday(datetime)
#> [1] 6
Para month()y wday()puede configurar label = TRUEpara devolver el nombre abreviado del mes o el día de la semana. Establecer abbr = FALSEpara devolver el nombre completo.

month(datetime, label = TRUE)
#> [1] Jul
#> 12 Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < ... < Dec
wday(datetime, label = TRUE, abbr = FALSE)
#> [1] Friday
#> 7 Levels: Sunday < Monday < Tuesday < Wednesday < Thursday < ... < Saturday
Podemos utilizar wday()para ver que más vuelos salen durante la semana que en el fin de semana:

flights_dt %>% 
  mutate(wday = wday(dep_time, label = TRUE)) %>% 
  ggplot(aes(x = wday)) +
    geom_bar()


Hay un patrón interesante si observamos el retraso promedio de salida por minuto dentro de una hora. ¡Parece que los vuelos que salen en minutos 20-30 y 50-60 tienen retrasos mucho más bajos que el resto de la hora!

flights_dt %>% 
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()) %>% 
  ggplot(aes(minute, avg_delay)) +
    geom_line()


Curiosamente, si miramos la hora programada de salida, no vemos un patrón tan fuerte:

sched_dep <- flights_dt %>% 
  mutate(minute = minute(sched_dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n())

ggplot(sched_dep, aes(minute, avg_delay)) +
  geom_line()


Entonces, ¿por qué vemos ese patrón con los tiempos reales de salida? Bueno, al igual que muchos datos recopilados por humanos, hay un fuerte sesgo hacia los vuelos que salen en tiempos de salida "agradables". Siempre esté atento a este tipo de patrón siempre que trabaje con datos que involucren el juicio humano.

ggplot(sched_dep, aes(minute, n)) +
  geom_line()


16.3.2 Redondeo
Un enfoque alternativo para el trazado de los componentes individuales es redondear la fecha a una unidad cercana de tiempo, con floor_date(), round_date(), y ceiling_date(). Cada función toma un vector de fechas para ajustar y luego el nombre de la unidad redondea hacia abajo (piso), redondea hacia arriba (techo) o redondea a. Esto, por ejemplo, nos permite trazar el número de vuelos por semana:

flights_dt %>% 
  count(week = floor_date(dep_time, "week")) %>% 
  ggplot(aes(week, n)) +
    geom_line()


Calcular la diferencia entre una fecha redondeada y no redondeada puede ser particularmente útil.

16.3.3 Configuración de componentes
También puede usar cada función de acceso para configurar los componentes de una fecha / hora:

(datetime <- ymd_hms("2016-07-08 12:34:56"))
#> [1] "2016-07-08 12:34:56 UTC"

year(datetime) <- 2020
datetime
#> [1] "2020-07-08 12:34:56 UTC"
month(datetime) <- 01
datetime
#> [1] "2020-01-08 12:34:56 UTC"
hour(datetime) <- hour(datetime) + 1
datetime
#> [1] "2020-01-08 13:34:56 UTC"
Alternativamente, en lugar de modificar en su lugar, puede crear una nueva fecha y hora con update(). Esto también le permite establecer múltiples valores a la vez.

update(datetime, year = 2020, month = 2, mday = 2, hour = 2)
#> [1] "2020-02-02 02:34:56 UTC"
Si los valores son demasiado grandes, se reiniciarán:

ymd("2015-02-01") %>% 
  update(mday = 30)
#> [1] "2015-03-02"
ymd("2015-02-01") %>% 
  update(hour = 400)
#> [1] "2015-02-17 16:00:00 UTC"
Puede usar update()para mostrar la distribución de vuelos a lo largo del día para cada día del año:

flights_dt %>% 
  mutate(dep_hour = update(dep_time, yday = 1)) %>% 
  ggplot(aes(dep_hour)) +
    geom_freqpoly(binwidth = 300)


Establecer componentes más grandes de una fecha en una constante es una poderosa técnica que le permite explorar patrones en los componentes más pequeños.

16.3.4 Ejercicios
¿Cómo cambia la distribución de los tiempos de vuelo en un día a lo largo del año?

Compare dep_time, sched_dep_timey dep_delay. ¿Son consistentes? Explica tus hallazgos

Compare air_timecon la duración entre la partida y la llegada. Explica tus hallazgos (Sugerencia: considere la ubicación del aeropuerto).

¿Cómo cambia el tiempo promedio de demora en el transcurso de un día? ¿Deberías usar dep_timeo sched_dep_time? ¿Por qué?

¿En qué día de la semana debería irse si quiere minimizar la posibilidad de un retraso?

¿Qué hace la distribución de diamonds$caraty flights$sched_dep_timesimilares?

Confirmo mi hipótesis de que las salidas anticipadas de los vuelos en los minutos 20-30 y 50-60 son causadas por vuelos programados que salen temprano. Sugerencia: crea una variable binaria que te diga si un vuelo se retrasó o no.

16.4 Lapso de tiempo
A continuación, aprenderá cómo funciona la aritmética con fechas, incluida la resta, la suma y la división. En el camino, aprenderás acerca de tres clases importantes que representan períodos de tiempo:

duraciones , que representan una cantidad exacta de segundos.
períodos , que representan unidades humanas como semanas y meses.
intervalos , que representan un punto inicial y final.
16.4.1 Duraciones
En R, cuando restas dos fechas, obtienes un objeto de tiempo diferido:

# How old is Hadley?
h_age <- today() - ymd(19791014)
h_age
#> Time difference of 14130 days
Un objeto de clase difftime registra un lapso de tiempo de segundos, minutos, horas, días o semanas. Esta ambigüedad puede hacer que sea un poco doloroso trabajar con ella, por lo que lubridate proporciona una alternativa que siempre usa segundos: la duración .

as.duration(h_age)
#> [1] "1220832000s (~38.69 years)"
Las duraciones vienen con un grupo de constructores convenientes:

dseconds(15)
#> [1] "15s"
dminutes(10)
#> [1] "600s (~10 minutes)"
dhours(c(12, 24))
#> [1] "43200s (~12 hours)" "86400s (~1 days)"
ddays(0:5)
#> [1] "0s"                "86400s (~1 days)"  "172800s (~2 days)"
#> [4] "259200s (~3 days)" "345600s (~4 days)" "432000s (~5 days)"
dweeks(3)
#> [1] "1814400s (~3 weeks)"
dyears(1)
#> [1] "31536000s (~52.14 weeks)"
Las duraciones siempre registran el lapso de tiempo en segundos. Las unidades más grandes se crean mediante la conversión de minutos, horas, días, semanas y años a segundos a la velocidad estándar (60 segundos en un minuto, 60 minutos en una hora, 24 horas en día, 7 días a la semana, los 365 días en una año).

Puede agregar y multiplicar duraciones:

2 * dyears(1)
#> [1] "63072000s (~2 years)"
dyears(1) + dweeks(12) + dhours(15)
#> [1] "38847600s (~1.23 years)"
Puede agregar y restar duraciones ay desde días:

tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
Sin embargo, dado que las duraciones representan una cantidad exacta de segundos, a veces puede obtener un resultado inesperado:

one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")

one_pm
#> [1] "2016-03-12 13:00:00 EST"
one_pm + ddays(1)
#> [1] "2016-03-13 14:00:00 EDT"
¿Por qué un día después de la 1 pm el 12 de marzo, a las 2 p.m. el 13 de marzo? Si observa detenidamente la fecha, también puede observar que las zonas horarias han cambiado. Debido a DST, el 12 de marzo solo tiene 23 horas, por lo que si agregamos un valor de segundos de días completos, terminamos con un horario diferente.

16.4.2 Períodos
Para resolver este problema, lubridate proporciona periodos . Los períodos son períodos de tiempo, pero no tienen una duración fija en segundos, sino que funcionan con tiempos "humanos", como días y meses. Eso les permite trabajar de una manera más intuitiva:

one_pm
#> [1] "2016-03-12 13:00:00 EST"
one_pm + days(1)
#> [1] "2016-03-13 13:00:00 EDT"
Al igual que las duraciones, los períodos se pueden crear con varias funciones amigables de constructor.

seconds(15)
#> [1] "15S"
minutes(10)
#> [1] "10M 0S"
hours(c(12, 24))
#> [1] "12H 0M 0S" "24H 0M 0S"
days(7)
#> [1] "7d 0H 0M 0S"
months(1:6)
#> [1] "1m 0d 0H 0M 0S" "2m 0d 0H 0M 0S" "3m 0d 0H 0M 0S" "4m 0d 0H 0M 0S"
#> [5] "5m 0d 0H 0M 0S" "6m 0d 0H 0M 0S"
weeks(3)
#> [1] "21d 0H 0M 0S"
years(1)
#> [1] "1y 0m 0d 0H 0M 0S"
Puedes agregar y multiplicar periodos:

10 * (months(6) + days(1))
#> [1] "60m 10d 0H 0M 0S"
days(50) + hours(25) + minutes(2)
#> [1] "50d 25H 2M 0S"
Y, por supuesto, agréguelos a las fechas. En comparación con las duraciones, los períodos tienen más probabilidades de hacer lo que esperas:

# A leap year
ymd("2016-01-01") + dyears(1)
#> [1] "2016-12-31"
ymd("2016-01-01") + years(1)
#> [1] "2017-01-01"

# Daylight Savings Time
one_pm + ddays(1)
#> [1] "2016-03-13 14:00:00 EDT"
one_pm + days(1)
#> [1] "2016-03-13 13:00:00 EDT"
Usemos períodos para arreglar una rareza relacionada con nuestras fechas de vuelo. Algunos aviones parecen haber llegado a su destino antes de partir de la ciudad de Nueva York.

flights_dt %>% 
  filter(arr_time < dep_time) 
#> # A tibble: 10,633 x 9
#>   origin dest  dep_delay arr_delay dep_time            sched_dep_time     
#>   <chr>  <chr>     <dbl>     <dbl> <dttm>              <dttm>             
#> 1 EWR    BQN           9        -4 2013-01-01 19:29:00 2013-01-01 19:20:00
#> 2 JFK    DFW          59        NA 2013-01-01 19:39:00 2013-01-01 18:40:00
#> 3 EWR    TPA          -2         9 2013-01-01 20:58:00 2013-01-01 21:00:00
#> 4 EWR    SJU          -6       -12 2013-01-01 21:02:00 2013-01-01 21:08:00
#> 5 EWR    SFO          11       -14 2013-01-01 21:08:00 2013-01-01 20:57:00
#> 6 LGA    FLL         -10        -2 2013-01-01 21:20:00 2013-01-01 21:30:00
#> # ... with 1.063e+04 more rows, and 3 more variables: arr_time <dttm>,
#> #   sched_arr_time <dttm>, air_time <dbl>
Estos son vuelos nocturnos. Utilizamos la misma información de fecha tanto para la hora de salida como para la hora de llegada, pero estos vuelos llegaron al día siguiente. Podemos solucionar esto añadiendo days(1)el tiempo de llegada de cada vuelo nocturno.

flights_dt <- flights_dt %>% 
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight * 1),
    sched_arr_time = sched_arr_time + days(overnight * 1)
  )
Ahora todos nuestros vuelos obedecen las leyes de la física.

flights_dt %>% 
  filter(overnight, arr_time < dep_time) 
#> # A tibble: 0 x 10
#> # ... with 10 variables: origin <chr>, dest <chr>, dep_delay <dbl>,
#> #   arr_delay <dbl>, dep_time <dttm>, sched_dep_time <dttm>,
#> #   arr_time <dttm>, sched_arr_time <dttm>, air_time <dbl>,
#> #   overnight <lgl>
16.4.3 Intervalos
Es obvio lo que dyears(1) / ddays(365)debería regresar: uno, porque las duraciones siempre están representadas por una cantidad de segundos, y una duración de un año se define como 365 días en segundos.

¿Qué debería years(1) / days(1)regresar? Bueno, si el año fue 2015 debería devolver 365, pero si fuera 2016, ¡debería devolver 366! No hay suficiente información para que lubridate brinde una única respuesta clara. Lo que hace en cambio es dar una estimación, con una advertencia:

years(1) / days(1)
#> estimate only: convert to intervals for accuracy
#> [1] 365
Si quieres una medida más precisa, tendrás que usar un intervalo . Un intervalo es una duración con un punto de inicio: eso lo hace preciso para que pueda determinar exactamente cuánto tiempo es:

next_year <- today() + years(1)
(today() %--% next_year) / ddays(1)
#> [1] 365
Para saber cuántos períodos entran en un intervalo, debe usar la división de enteros:

(today() %--% next_year) %/% days(1)
#> Note: method with signature 'Timespan#Timespan' chosen for function '%/%',
#>  target signature 'Interval#Period'.
#>  "Interval#ANY", "ANY#Period" would also be valid
#> [1] 365
16.4.4 Resumen
¿Cómo se elige entre duración, períodos e intervalos? Como siempre, elija la estructura de datos más simple que resuelva su problema. Si solo te importa el tiempo físico, usa una duración; si necesita agregar tiempos humanos, use un punto; si necesita saber cuánto tiempo dura un lapso en unidades humanas, use un intervalo.

La Figura 16.1 resume las operaciones aritméticas permitidas entre los diferentes tipos de datos.

 Las operaciones aritméticas permitidas entre pares de clases de fecha / hora.
Figura 16.1: Las operaciones aritméticas permitidas entre pares de clases de fecha / hora.

16.4.5 Ejercicios
¿Por qué hay months()pero no dmonths()?

Explíquele days(overnight * 1)a alguien que acaba de comenzar a aprender R. ¿Cómo funciona?

Cree un vector de fechas para el primer día de cada mes en 2015. Cree un vector de fechas que indique el primer día de cada mes en el año actual .

Escriba una función que, dada su fecha de cumpleaños (como fecha), devuelva la edad que tenga en años.

¿Por qué no puede (today() %--% (today() + years(1)) / months(1)funcionar?

16.5 Zonas horarias
Las zonas horarias son un tema enormemente complicado debido a su interacción con entidades geopolíticas. Afortunadamente, no necesitamos profundizar en todos los detalles, ya que no son todos importantes para el análisis de datos, pero hay algunos desafíos que debemos enfrentar.

El primer desafío es que los nombres diarios de las zonas horarias tienden a ser ambiguos. Por ejemplo, si eres estadounidense, probablemente estés familiarizado con EST o Eastern Standard Time. Sin embargo, tanto Australia como Canadá también tienen EST. Para evitar confusiones, R usa las zonas horarias estándar internacionales de IANA. Estos usan un esquema de nombres consistente "/", Típicamente en la forma" <continente> / <ciudad> "(hay algunas excepciones porque no todos los países se encuentran en un continente). Los ejemplos incluyen "America / New_York", "Europe / Paris" y "Pacific / Auckland".

Quizás se pregunte por qué la zona horaria utiliza una ciudad, cuando normalmente piensa en zonas horarias asociadas a un país o región dentro de un país. Esto se debe a que la base de datos IANA tiene que registrar décadas de reglas de zona horaria. En el transcurso de las décadas, los países cambian los nombres (o se separan) con bastante frecuencia, pero los nombres de las ciudades tienden a permanecer igual. Otro problema es que el nombre debe reflejar no solo el comportamiento actual, sino también el historial completo. Por ejemplo, hay zonas horarias para "America / New_York" y "America / Detroit". Ambas ciudades actualmente usan Eastern Standard Time, pero en 1969-1972 Michigan (el estado en el que se encuentra Detroit) no siguió el horario de verano, por lo que necesita un nombre diferente. Vale la pena leer la base de datos de la zona horaria en bruto (disponible en http://www.iana.org/time-zones) solo para leer algunas de estas historias!

Puedes descubrir con qué piensa R tu zona horaria actual Sys.timezone():

Sys.timezone()
#> [1] "UTC"
(Si R no sabe, obtendrá una NA.)

Y vea la lista completa de todos los nombres de zona horaria con OlsonNames():

length(OlsonNames())
#> [1] 606
head(OlsonNames())
#> [1] "Africa/Abidjan"     "Africa/Accra"       "Africa/Addis_Ababa"
#> [4] "Africa/Algiers"     "Africa/Asmara"      "Africa/Asmera"
En R, la zona horaria es un atributo de la fecha y hora que solo controla la impresión. Por ejemplo, estos tres objetos representan el mismo instante en el tiempo:

(x1 <- ymd_hms("2015-06-01 12:00:00", tz = "America/New_York"))
#> [1] "2015-06-01 12:00:00 EDT"
(x2 <- ymd_hms("2015-06-01 18:00:00", tz = "Europe/Copenhagen"))
#> [1] "2015-06-01 18:00:00 CEST"
(x3 <- ymd_hms("2015-06-02 04:00:00", tz = "Pacific/Auckland"))
#> [1] "2015-06-02 04:00:00 NZST"
Puedes verificar que son el mismo tiempo que usas la resta:

x1 - x2
#> Time difference of 0 secs
x1 - x3
#> Time difference of 0 secs
A menos que se especifique lo contrario, lubridate siempre usa UTC. UTC (tiempo universal coordinado) es la zona horaria estándar utilizada por la comunidad científica y más o menos equivalente a su predecesor, GMT (Greenwich Mean Time). No tiene horario de verano, lo que hace una representación conveniente para el cálculo. Las operaciones que combinan fechas y horas, como c(), a menudo disminuirán la zona horaria. En ese caso, los horarios se mostrarán en su zona horaria local:

x4 <- c(x1, x2, x3)
x4
#> [1] "2015-06-01 12:00:00 EDT" "2015-06-01 12:00:00 EDT"
#> [3] "2015-06-01 12:00:00 EDT"
Puede cambiar la zona horaria de dos maneras:

Mantenga el mismo instante a tiempo y cambie la forma en que se muestra. Úselo cuando el instante sea correcto, pero desea una visualización más natural.

x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
x4a
#> [1] "2015-06-02 02:30:00 +1030" "2015-06-02 02:30:00 +1030"
#> [3] "2015-06-02 02:30:00 +1030"
x4a - x4
#> Time differences in secs
#> [1] 0 0 0
(Esto también ilustra otro desafío de las zonas de tiempo: ¡no son todas las compensaciones de horas enteras!)

Cambia el instante subyacente a tiempo. Úselo cuando tenga un instante que haya sido etiquetado con la zona horaria incorrecta, y necesita repararlo.

x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
x4b
#> [1] "2015-06-01 12:00:00 +1030" "2015-06-01 12:00:00 +1030"
#> [3] "2015-06-01 12:00:00 +1030"
x4b - x4
#> Time differences in hours
#> [1] -14.5 -14.5 -14.5