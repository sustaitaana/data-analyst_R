---
title: "Ciencia de Datos con R"
subtitle: "3. Advanced tools for Analysis"
author: "Ana Sustaita, sustaitaana@gmail.com"
output:
  html_document:
    df_print: paged
    highlight: tango
    theme: flatly
  pdf_document: default
  word_document: default
---

![](../images/greenshark.png)

# {.tabset .tabset-fade .tabset-pills}

## stringr

`stringr` no es parte del `tidyverse`, por lo que debemos instalarlo y cargarlo explícitamente.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(stringr)
```

### Conceptos básicos

Podemos crear cadenas con comillas simples o comillas dobles. A diferencia de otros lenguajes, no hay diferencia en el comportamiento. Es recomendable usar siempre `"`, a menos que queramos crear una cadena que contenga múltiples comillas dobles.

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
string1 <- "Esto es una cadena"
string2 <- 'Si queremos incluir una "cita" dentro de una cadena, usamos comillas simples'
```

Si olvidamos cerrar una cadena, veremos `+`, el caracter de continuación:

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
# > "Esta es una cadena sin comillas de cierre
# + 
# + 
# + AYUDA, ESTOY ATORADO!
```

Si esto nos pasa, sólo debemos presionar Escape e intentar nuevamente.

Para incluir una comilla simple o doble literal en una cadena, podemos usar `\` para "escaparla":

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
double_quote <- "\"" # o '"'
single_quote <- '\'' # o "'"
```

Esto significa que si deseamos incluir una barra invertida, tendremos que duplicarla: "\\".

Debemos tener en cuenta que la representación impresa de una cadena no es la misma que la cadena por si misma, esto se debe a que la representación impresa muestra los escapes. Para ver el contenido "crudo" de la cadena, usamos `writeLines()`:

```{r, message=FALSE, warning=FALSE}
x <- c("\"", "\\")
x

writeLines(x)
```

Hay un puñado de otros caracteres especiales. Los más comunes son `"\n"`, nueva línea y `"\t"`, tab, pero podemos ver la lista completa en la ayuda de `"`: `?'"'` o `?"'"`. En ocasiones nos podemos encontrar con cadenas como `"\u00b5"` esta es una forma de escribir caracteres no alfabéticos que funcionan en todas las plataformas:

```{r, message=FALSE, warning=FALSE}
x <- "\u00b5"
x
```

Múltiples cadenas a menudo se almacenan en un vector de caracteres, que podemos crear con c():

```{r, message=FALSE, warning=FALSE}
c("one", "two", "three")
```

#### Longitud

R base contiene muchas funciones para trabajar con cadenas pero las evitaremos porque pueden ser inconsistentes, lo que las hace difíciles de recordar. En su lugar usaremos funciones de `stringr`. Estas tienen nombres más intuitivos y todos comienzan con `str_`. Por ejemplo, `str_length()` nos devuelve la cantidad de caracteres en una cadena:

```{r, message=FALSE, warning=FALSE}
str_length(c("a", "Ciencia de Datos con R", NA))
```


El prefijo común `str_` es particularmente útil si utilizamos RStudio, ya que al escribir `str_` activará la función autocompletar, lo que nos permite ver todas las funciones del `stringr`:

![](../images/stringr-autocomplete.png)

#### Combinando cadenas

Para combinar dos o más cadenas, usamos `str_c()`:

```{r, message=FALSE, warning=FALSE}
str_c("x", "y")

str_c("x", "y", "z")
```

Podemos usar el argumento `sep` para controlar la forma en que se separan las cadenas de texto:

```{r, message=FALSE, warning=FALSE}
str_c("x", "y", sep = ", ")
```

Como en la mayoría de las otras funciones en R, los valores faltantes son contagiosos. Si deseamos que se impriman como `"NA"`, usamos `str_replace_na()`:


```{r, message=FALSE, warning=FALSE}
x <- c("abc", NA)
str_c("|-", x, "-|")

str_c("|-", str_replace_na(x), "-|")
```

Como se muestra arriba, `str_c()` se vectoriza, y recicla automáticamente vectores más cortos a la misma longitud que el más largo:

```{r, message=FALSE, warning=FALSE}
str_c("prefix-", c("a", "b", "c"), "-suffix")
```

Los objetos de longitud 0 se eliminan en "silencio". Esto es particularmente útil en conjunto con `if`:


```{r, message=FALSE, warning=FALSE}
name <- "Ana"
time_of_day <- "días"
birthday <- FALSE

str_c(
  "Buenos ", time_of_day, " ", name,
  if (birthday) " y FELIZ CUMPLEAÑOS",
  "."
)
```

Para colapsar un vector de cadenas en una sola cadena, usamos `collapse`:

```{r, message=FALSE, warning=FALSE}
str_c(c("x", "y", "z"), collapse = ", ")
```


#### Subconjuntos de cadenas

Podemos extraer partes de una cadena usando `str_sub()`. Además de la cadena, `str_sub()` necesita los argumentos `start` y `end` que dan la posición (inclusiva) de la subcadena:


```{r, message=FALSE, warning=FALSE}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)

str_sub(x, -3, -1)
```

Debemos notar que `str_sub()` no fallará si la cadena es demasiado corta, solo regresará tanto como sea posible:

```{r, message=FALSE, warning=FALSE}
str_sub("a", 1, 5)
```

También podemos usar la forma de asignación de `str_sub()` para modificar cadenas:


```{r, message=FALSE, warning=FALSE}
str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))
x
```


#### Locales

Cambiar de mayúsculas a minúsculas es más complicado de lo que podría parecer a primera vista, ya que los diferentes idiomas tienen diferentes reglas para cambiar de mayúscula a minúscula. Podemos elegir qué conjunto de reglas usar al especificar una configuración regional:

```{r, message=FALSE, warning=FALSE}
# El Turco tiene dos i's: con y sin punto y tiene
# una regla diferente para pasarlas a mayúsculas:
str_to_upper(c("i", "ı"))

str_to_upper(c("i", "ı"), locale = "tr")
```


La configuración regional se especifica como un código de idioma ISO 639, que es una abreviación de dos o tres letras. Podemos consultar la lista de [Wikipedia](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) para conocer el código de distintos idiomas, incluído el nuestro. Si dejamos la configuración regional en blanco, usará la configuración regional actual, tal como lo proporciona nuestro sistema operativo.

Otra operación importante que se ve afectada por la configuración regional es el ordenamiento. Las funciones de R base `order()` y `sort()` ordenan cadenas usando la configuración regional actual. Si deseamos un comportamiento robusto en diferentes computadoras, es posible que debamos utilizar `str_sort()` y `str_order()` que toman un argumento adicional `locale`:

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "eggplant", "banana")
str_sort(x, locale = "en")  # Inglés

str_sort(x, locale = "haw") # Hawaiano
```


### Patrones con expresiones regulares

Regexps es un lenguaje muy conciso que nos permite describir patrones en cadenas.

Para aprender expresiones regulares, usaremos `str_view()` y `str_view_all()`. Estas funciones toman un vector de caracteres y una expresión regular y muestran cómo coinciden. Comenzaremos con expresiones regulares muy simples y luego gradualmente lo complicaremos. Una vez que dominemos la coincidencia de patrones, aprenderemos cómo aplicar esas ideas con varias funciones de cadenas.

#### Patrones básicos

Los patrones más simples coinciden con cadenas exactas:

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "banana", "pear")
str_view(x, "an")
```

El siguiente paso en la complejidad es `.`, que coincide con cualquier caracter (excepto una nueva línea):

```{r, message=FALSE, warning=FALSE}
str_view(x, ".a.")
```

Pero si "`.`" coincide con cualquier caracter, ¿cómo encontramos el caracter "`.`"? Debemos usar un "escape" para decirle a la expresión regular que deseamos coincidirlo exactamente en vez de usar su comportamiento especial. Al igual que las cadenas, las expresiones regulares usan la barra invertida, `\`, para escapar del comportamiento especial. Entonces, para que coincida con un `.`, necesitamos la expresión regular `\.`. Lamentablemente, esto crea un problema. Usamos cadenas para representar expresiones regulares, y `\` también se usa como un símbolo de escape en cadenas. Entonces para crear la expresión regular `\.` necesitamos la cadena `"\\."`.

```{r, message=FALSE, warning=FALSE}
# Para crear la expresión regular, necesitamos \\
dot <- "\\."

# Pero la expresión sólo contiene un backslash:
writeLines(dot)

# Con esto, le decimos a R que busque un . explícito
str_view(c("abc", "a.c", "bef"), "a\\.c")
```


Si `\` se usa como un carácter de escape en expresiones regulares, ¿cómo se combina un literal `\`? Necesitamos escapar, creando la expresión regular `\\`. Para crear esa expresión regular, necesitamos usar una cadena, que también necesita escapar `\`. Eso significa que para hacer coincidir un literal `\` necesitamos escribir `"\\\\"` ¡necesitamos cuatro barras invertidas para que coincida con una!

```{r, message=FALSE, warning=FALSE}
x <- "a\\b"
writeLines(x)

str_view(x, "\\\\")
```

A partir de ahora, escribiremos la expresión regular como `\.` y las cadenas que representan la expresión regular como `"\\."`.


#### Anclajes

Por defecto, las expresiones regulares coincidirán con cualquier parte de una cadena. A menudo es útil anclar la expresión regular para que coincida desde el principio o el final de la cadena. Podemos usar:

+ `^` para que coincida con el comienzo de la cadena.

+ `$` para que coincida el final de la cadena.

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "banana", "pear")
str_view(x, "^a")

str_view(x, "a$")
```

Para recordar cuál es cuál, prueba esta mnemotecnia de [Evan Misshula](https://twitter.com/emisshula/status/323863393167613953): si comienzas con potencia (`^`), terminas con dinero (`$`).

Para forzar una expresión regular a que sólo coincida con una cadena completa, debemos anclarla con ambos `^` y `$`:

```{r, message=FALSE, warning=FALSE}
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")

str_view(x, "^apple$")
```

También podemos coincidir el límite entre las palabras con `\b`.

#### Clases de caracteres y alternativas

Hay una serie de patrones especiales que coinciden con más de un caracter. Ya vimos `.`, que coincide con cualquier caracter que no sea una nueva línea. Hay otras cuatro herramientas útiles:

+ `\d`: coincide con cualquier dígito.

+ `\s`: coincide con cualquier espacio en blanco.

+ `[abc]`: coincide con a, b, o c.

+ `[^abc]`: coincide con cualquier cosa excepto a, b, o c.

Recordemos que para crear una expresión regular que contenga `\d` o `\s`, debemos escapar `\` de la cadena, por lo que escribiremos `"\\d"` o `"\\s"`.

Una clase de caracteres que contenga un solo carácter es una buena alternativa a los escapes de barra invertida cuando se desea incluir un metacarácter único en una expresión regular. Muchas personas lo encuentran más legible.

```{r, message=FALSE, warning=FALSE}
# Buscar un caracter que normalmente tiene un significado especial en regex
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")

str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")

str_view(c("abc", "a.c", "a*c", "a c"), "a[ ]")
```


Esto funciona para la mayoría (pero no todos) de los metacaracteres de expresiones regulares: `$` `.` `|` `?` `*` `+` `(` `)` `[` `{`. Desafortunadamente, algunos caracteres tienen un significado especial incluso dentro de una clase de caracteres y deben manejarse con escapes de barra invertida: `]` `\` `^` y `-`.

Podemos usar la alternancia para elegir uno o más patrones alternativos. Por ejemplo, `abc|d..f` coincidirá con `"abc"` o `"deaf"`. Notemos que la precedencia para `|` es baja, por lo que `abc|xyz` coincide `abc` o `xyz` no `abcyz` o `abxyz`. Al igual que con las expresiones matemáticas, si la precedencia se vuelve confusa, usamos paréntesis para dejar en claro lo que deseamos:

```{r, message=FALSE, warning=FALSE}
str_view(c("grey", "gray"), "gr(e|a)y")
```

#### Repetición

El siguiente paso en complejidad implica controlar cuántas veces coincide un patrón:

+ `?`: 0 o 1

+ `+`: 1 o más

+ `*`: 0 o más

```{r, message=FALSE, warning=FALSE}
x <- "1888 es el año más largo en números romanos: MDCCCLXXXVIII"
str_view(x, "CC?")

str_view(x, "CC+")

str_view(x, 'C[LX]+')
```

Notemos que la precedencia de estos operadores es alta, por lo que podemos escribir: `colou?r` para que coincida con la ortografía estadounidense o británica, por ejemplo. Eso significa que la mayoría de los usos necesitarán paréntesis, como `bana(na)+`.

También podemos especificar el número de coincidencias con precisión:

+ `{n}`: exactamente n
+ `{n,}`: n o más
+ `{,m}`: a lo sumo m
+ `{n,m}`: entre n y m

```{r, message=FALSE, warning=FALSE}
str_view(x, "C{2}")

str_view(x, "C{2,}")

str_view(x, "C{2,3}")
```

Por defecto, estas coincidencias son "codiciosas": coincidirán con la cadena más larga posible. Podemos hacerlas "flojas", haciendo coincidir la cadena más corta posible poniendo un `?` después de ellas. Esta es una característica avanzada de las expresiones regulares, pero es útil saber que existe:

```{r, message=FALSE, warning=FALSE}
str_view(x, 'C{2,3}?')

str_view(x, 'C[LX]+?')
```

#### Agrupación y referencias

Anteriormente, aprendimos que los paréntesis son una forma de desambiguar expresiones complejas. Los paréntesis también crean un grupo de captura *numerado* (número 1, 2, etc.). Un grupo de captura almacena *la parte de la cadena* que coincide con la parte de la expresión regular dentro de los paréntesis. Podemos consultar textos anteriores con un grupo de captura con *referencias*, como `\1`, `\2`, etc. Por ejemplo, la siguiente expresión regular encuentra todas las frutas que tienen un par de letras repetidas.

```{r, message=FALSE, warning=FALSE}
str_view(fruit, "(..)\\1", match = TRUE)
```

(Pronto, veremos cómo son útiles junto con `str_match()`.)

### Herramientas

Ahora que conocemos los conceptos básicos de las expresiones regulares, es hora de aprender cómo aplicarlas a problemas reales. Aprenderemos funciones de `stringr` que nos permiten:

+ Determinar qué cadenas coinciden con un patrón.
+ Encontrar las posiciones de las coincidencias.
+ Extraer el contenido de las coincidencias.
+ Reemplazar coincidencias con nuevos valores.
+ Dividir una cadena basado en una coincidencia.

#### Detectar coincidencias

Para determinar si un vector de caracteres coincide con un patrón, usamos `str_detect()`. Devuelve un vector lógico con la misma longitud que la entrada:

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "banana", "pear")
str_detect(x, "e")
```


Recordemos que cuando se utiliza un vector lógico en un contexto numérico, `FALSE` se convierte en 0 y `TRUE` se convierte en 1. Esto hace que `sum()` y `mean()` sean utiles si deseamos responder preguntas sobre coincidencias en un vector más grande:

```{r, message=FALSE, warning=FALSE}
# ¿Cuántas palabras empiezan con t?
sum(str_detect(words, "^t"))

# ¿Qué proporción de palabras terminan en vocal?
mean(str_detect(words, "[aeiou]$"))
```

Cuando tenemos condiciones lógicas complejas (por ejemplo, coincidir con `a` o `b`, pero no con `c` a menos que `d`) a menudo es más fácil combinar múltiples llamadas de `str_detect()` con operadores lógicos, en lugar de tratar de crear una única expresión regular. Por ejemplo, aquí hay dos formas de encontrar todas las palabras que no contienen vocales:

```{r, message=FALSE, warning=FALSE}
# Encuentra todas las palabras que contengan al menos una vocal, y niegalas
no_vowels_1 <- !str_detect(words, "[aeiou]")

# Encuentra todas las palabras que estén compuestas por puras consonantes
no_vowels_2 <- str_detect(words, "^[^aeiou]+$")
identical(no_vowels_1, no_vowels_2)
```


Los resultados son idénticos, pero el primer enfoque es significativamente más fácil de entender. Si una expresión regular se vuelve demasiado complicada, debemos intentar dividirla en partes más pequeñas, dándole un nombre a cada pieza y luego combinando las piezas con operaciones lógicas.

Un uso común de `str_detect()` es seleccionar los elementos que coinciden con un patrón. Podemos hacer esto con un subconjunto lógico o el `str_subset()` conveniente :


```{r, message=FALSE, warning=FALSE}
words[str_detect(words, "x$")]

str_subset(words, "x$")
```


Normalmente, sin embargo, las cadenas serán una columna de un data frame, y en su lugar preferiremos usar `filter`:


```{r, message=FALSE, warning=FALSE}
df <- tibble(
  word = words, 
  i = seq_along(word)
)
df %>% 
  filter(str_detect(words, "x$"))
```


Una variación de `str_detect()` es `str_count()`: en lugar de un simple sí o no, nos dice cuántas coincidencias hay en una cadena:

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "banana", "pear")
str_count(x, "a")

# En promedio, ¿cuántas vocales por palabra?
mean(str_count(words, "[aeiou]"))
```

Es natural usar `str_count()` con `mutate()`:

```{r, message=FALSE, warning=FALSE}
df %>% 
  mutate(
    vowels = str_count(word, "[aeiou]"),
    consonants = str_count(word, "[^aeiou]")
  )
```

Debemos tener en cuenta que las coincidencias nunca se superponen. Por ejemplo, en `"abababa"`, ¿cuántas veces coincidirá el patrón `"aba"`? Las expresiones regulares dicen dos, no tres:

```{r, message=FALSE, warning=FALSE}
str_count("abababa", "aba")

str_view_all("abababa", "aba")
```


Muchas funciones de `stringr` vienen en pares: una función funciona con una sola coincidencia, y la otra funciona con todas las coincidencias. La segunda función tendrá el sufijo `_all`.


#### Extraer coincidencias

Para extraer el texto real de una coincidencia, usamos `str_extract()`. Para demostrarlo, vamos a necesitar un ejemplo más complicado. Usaremos las [Oraciones de Harvard](https://en.wikipedia.org/wiki/Harvard_sentences), que fueron diseñadas para probar sistemas VOIP, pero también son útiles para practicar expresiones regulares. Estas se encuentran en `stringr::sentences`:

```{r, message=FALSE, warning=FALSE}
length(sentences)

head(sentences)
```

Imagina que queremos encontrar todas las oraciones que contienen un color. Primero creamos un vector de nombres de colores y luego lo convertimos en una única expresión regular:

```{r, message=FALSE, warning=FALSE}
colours <- c("red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match
```


Ahora podemos seleccionar las oraciones que contienen un color, y luego extraer el color para descubrir cuál es:

```{r, message=FALSE, warning=FALSE}
has_colour <- str_subset(sentences, colour_match)
matches <- str_extract(has_colour, colour_match)
head(matches)
```

Notemos que `str_extract()` solo extrae la primera coincidencia. Podemos ver eso más fácilmente al seleccionar primero todas las oraciones que tienen más de 1 coincidencia:

```{r, message=FALSE, warning=FALSE}
more <- sentences[str_count(sentences, colour_match) > 1]
str_view_all(more, colour_match)

str_extract(more, colour_match)
```

Este es un patrón común para las funciones de cadenas, porque trabajar con una sola coincidencia nos permite utilizar estructuras de datos mucho más simples. Para obtener todas las coincidencias, usa `str_extract_all()`. Devuelve una lista:

```{r, message=FALSE, warning=FALSE}
str_extract_all(more, colour_match)
```

Si usamos `simplify = TRUE`, `str_extract_all()` devolverá una matriz con coincidencias cortas expandidas a la misma longitud que la más larga:

```{r, message=FALSE, warning=FALSE}
str_extract_all(more, colour_match, simplify = TRUE)

x <- c("a", "a b", "a b c")
str_extract_all(x, "[a-z]", simplify = TRUE)
```

##### Ejercicios

1. En el ejemplo anterior, es posible que hayas notado que la expresión regular coincide con "flickered", que no es un color. Modifica la expresión regular para solucionar el problema.

2. De los datos de las oraciones de Harvard, extrae:

    + La primera palabra de cada oración
    + Todas las palabras que terminan en `ing`.
    + Todos los plurales
    
    
#### Coincidencias agrupadas

Ya sabemos que podemos hacer uso de el paréntesis para aclarar la precedencia y para referencias al momento de la comparación. También podemos usarlo para extraer partes de una coincidencia compleja. Por ejemplo, imagina que queremos extraer sustantivos de las oraciones. Como heurística, buscaremos cualquier palabra que venga después de `"a"` o `"the"`. Definir una "palabra" en una expresión regular es un poco complicado, así que utilizaremos una aproximación simple: una secuencia de al menos un carácter que no es un espacio.

```{r, message=FALSE, warning=FALSE}
noun <- "(a|the) ([^ ]+)"

has_noun <- sentences %>%
  str_subset(noun) %>%
  head(10)
has_noun %>% 
  str_extract(noun)
```

`str_extract()` nos da la coincidencia completa, `str_match()` nos da a cada componente individual. En lugar de un vector de caracteres, devuelve una matriz, con una columna para la coincidencia completa seguida de una columna para cada grupo:

```{r, message=FALSE, warning=FALSE}
has_noun %>% 
  str_match(noun)
```

(Como era de esperar, nuestra heurística para detectar sustantivos es pobre, y también capta adjetivos como `smooth` y `parked`).

Si tenemos los datos en un `tibble`, a menudo es más fácil de usar `tidyr::extract()`. Funciona de la misma manera `str_match()` pero requiere que nombremos las coincidencias, que luego se colocan en columnas nuevas:

```{r, message=FALSE, warning=FALSE}
tibble(sentence = sentences) %>% 
  tidyr::extract(
    sentence, c("article", "noun"), "(a|the) ([^ ]+)", 
    remove = FALSE
  )
```

Como en `str_extract()`, si queremos todas las coincidencias para cada cadena, necesitaremos `str_match_all()`.

#### Reemplazar coincidencias

`str_replace()` y `str_replace_all()` nos permiten reemplazar coincidencias con nuevas cadenas. El uso más simple es reemplazar un patrón con una cadena fija:

```{r, message=FALSE, warning=FALSE}
x <- c("apple", "pear", "banana")
str_replace(x, "[aeiou]", "-")

str_replace_all(x, "[aeiou]", "-")
```


Con `str_replace_all()` podemos realizar reemplazos múltiples mediante el suministro de un vector nombrado:

```{r, message=FALSE, warning=FALSE}
x <- c("1 house", "2 cars", "3 people")
str_replace_all(x, c("1" = "one", "2" = "two", "3" = "three"))
```


En lugar de reemplazar con una cadena fija, podemos usar referencias para insertar componentes de la coincidencia. Cambiemos la segunda por la tercera palabra:

```{r, message=FALSE, warning=FALSE}
sentences %>% 
  str_replace("([^ ]+) ([^ ]+) ([^ ]+)", "\\1 \\3 \\2") %>% 
  head(5)
```

#### División

Usamos `str_split()` para dividir una cadena en pedazos. Por ejemplo, podríamos dividir oraciones en palabras:

```{r, message=FALSE, warning=FALSE}
sentences %>%
  head(5) %>% 
  str_split(" ")
```


Debido a que cada componente puede contener un número diferente de elementos, esto devuelve una lista. Si estamos trabajando con un vector de longitud 1, lo más fácil es extraer el primer elemento de la lista:

```{r, message=FALSE, warning=FALSE}
"a|b|c|d" %>% 
  str_split("\\|") %>% 
  .[[1]]
```


De lo contrario, al igual que las otras funciones de cadena que devuelven una lista, podemos usar `simplify = TRUE` para obtener una matriz:

```{r, message=FALSE, warning=FALSE}
sentences %>%
  head(5) %>% 
  str_split(" ", simplify = TRUE)
```

También podemos pedir un número máximo de elementos:

```{r, message=FALSE, warning=FALSE}
fields <- c("Nombre: Ana", "País: México", "Edad: 29")
fields %>% str_split(": ", n = 2, simplify = TRUE)
```


En lugar de dividir cadenas por patrones, podemos dividir por carácter, línea, oración y palabra usando `boundary()`:

```{r, message=FALSE, warning=FALSE}
x <- "Esta es una oración. Esta es otra oración."
str_view_all(x, boundary("word"))

str_split(x, " ")[[1]]

str_split(x, boundary("word"))[[1]]
```

#### Buscar coincidencias

`str_locate()` y `str_locate_all()` nos darán las posiciones inicial y final de cada coincidencia. Estos son particularmente útiles cuando ninguna de las otras funciones hace exactamente lo que deseamos. Podemos usar `str_locate()` para encontrar el patrón coincidente, `str_sub()` para extraerlo y/o modificarlo.

### Otros tipos de patrones

Cuando utilizamos un patrón que es una cadena, se envuelve automáticamente en una llamada a `regex()`:

```{r, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE}
# La llamada regular:
str_view(fruit, "nana")
# Es una versión corta de:
str_view(fruit, regex("nana"))
```


Podemos usar los otros argumentos de `regex()` para controlar los detalles de la coincidencia:

+ `ignore_case = TRUE` permite que los caracteres coincidan con sus mayúsculas o minúsculas. Esto siempre usa la configuración regional actual.

```{r, message=FALSE, warning=FALSE}
bananas <- c("banana", "Banana", "BANANA")
str_view(bananas, "banana")

str_view(bananas, regex("banana", ignore_case = TRUE))
```


+ `multiline = TRUE` permite a `^` y `$` coincidir el inicio y el final de cada línea en lugar del inicio y el final de la cadena completa.

```{r, message=FALSE, warning=FALSE}
x <- "Line 1\nLine 2\nLine 3"
str_extract_all(x, "^Line")[[1]]

str_extract_all(x, regex("^Line", multiline = TRUE))[[1]]
```


+ `comments = TRUE` nos permite usar comentarios y espacios en blanco para hacer que las expresiones regulares complejas sean más comprensibles. Los espacios son ignorados, como lo es todo después `#`. Para que coincida con un espacio literal, necesitamos escaparlo: `"\\ "`.


```{r, message=FALSE, warning=FALSE}
phone <- regex("
  \\(?     # optional opening parens
  (\\d{3}) # area code
  [) -]?   # optional closing parens, space, or dash
  (\\d{3}) # another three numbers
  [ -]?    # optional space or dash
  (\\d{3}) # three more numbers
  ", comments = TRUE)

str_match("514-791-8141", phone)
```


+ `dotall = TRUE` permite que `.` coincida con todo, incluso `\n`.

Hay otras tres funciones que podemos usar en lugar de `regex()`:

+ `fixed()`: coincide exactamente con la secuencia de bytes especificada. Ignora todas las expresiones regulares especiales y opera a un nivel muy bajo. Esto nos permite evitar el escape complejo y puede ser mucho más rápido que las expresiones regulares. El siguiente microbenchmark muestra que es aproximadamente 3 veces más rápido en un ejemplo simple.

```{r, message=FALSE, warning=FALSE}
library(microbenchmark)
microbenchmark::microbenchmark(
  fixed = str_detect(sentences, fixed("the")),
  regex = str_detect(sentences, "the"),
  times = 20
)
```


Debemos tener cuidado al usar `fixed()` con datos que no sean en inglés. Es problemático porque a menudo hay múltiples formas de representar al mismo caracter. Por ejemplo, hay dos formas de definir `"á"`: como un solo caracter o como una `"a"` más un acento:

```{r, message=FALSE, warning=FALSE}
a1 <- "\u00e1"
a2 <- "a\u0301"
c(a1, a2)

a1 == a2
```

Se representan de forma idéntica, pero debido a que están definidos de manera diferente, `fixed()` no encuentran una coincidencia. En cambio, podemos usar `coll()`, definido a continuación, para respetar las reglas de comparación de caracteres humanos:

```{r, message=FALSE, warning=FALSE}
str_detect(a1, fixed(a2))

str_detect(a1, coll(a2))
```


+ `coll()`: compara cadenas usando las reglas de colación estándar. Esto es útil para hacer coincidencias insensibles a mayúscuas y minúsculas. Notemos que `coll()` toma un parámetro `locale` que controla qué reglas se usan para comparar caracteres. Desafortunadamente, ¡diferentes partes del mundo usan diferentes reglas!

```{r, message=FALSE, warning=FALSE}
# Esto significa que debemos estar conscientes de las diferencias cuando hagamos coincidencias con sensibilidad de mayúsculas:
i <- c("I", "İ", "i", "ı")
i

str_subset(i, coll("i", ignore_case = TRUE))

str_subset(i, coll("i", ignore_case = TRUE, locale = "tr"))
```

Tanto `fixed()` como `regex()` tienen argumentos `ignore_case`, pero no permiten que podamos elegir la configuración regional: siempre utilizan la configuración regional predeterminada. Podemos verla así:

```{r, message=FALSE, warning=FALSE}
stringi::stri_locale_info()
```

La desventaja de `coll()` es la velocidad porque las reglas para reconocer qué caracteres son los mismos son complicadas, `coll()` es relativamente lento en comparación con `regex()` y `fixed()`.

+ Como vimos con `str_split()` podemos usar `boundary()` para unir límites. También podemos usarlo con las otras funciones:

```{r, message=FALSE, warning=FALSE}
x <- "Esta es una oración."
str_view_all(x, boundary("word"))

str_extract_all(x, boundary("word"))
```

### Otros usos de expresiones regulares

Hay dos funciones útiles en R base que también usan expresiones regulares:

+ `apropos()` busca todos los objetos disponibles del entorno global. Esto es útil si no recordamos el nombre de alguna función.

```{r, message=FALSE, warning=FALSE}
apropos("replace")
```


+ `dir()` lista todos los archivos en un directorio. El argumento `pattern` toma una expresión regular y solo devuelve nombres de archivos que coinciden con el patrón. Por ejemplo, podemos encontrar todos los archivos R Markdown en el directorio actual con:

```{r, message=FALSE, warning=FALSE}
head(dir(pattern = "\\.Rmd$"))
```

(Si te sientes más cómodo con "globs" como `*.Rmd`, puedes convertirlos a expresiones regulares con `glob2rx()`):

### stringi

`stringr` está construido sobre el paquete `stringi`. `stringr` es útil cuando estamos aprendiendo porque expone un conjunto mínimo de funciones, que se han seleccionado cuidadosamente para manejar las funciones de manipulación de cadenas más comunes. `stringi`, por otro lado, está diseñado para ser completo. Contiene casi todas las funciones que podamos necesitar: `stringi` tiene 234 funciones contra las 46 de `stringr`.

Si te encuentras luchando por hacer algo en `stringr`, vale la pena echarle un vistazo a `stringi`. Los paquetes funcionan de manera muy similar, por lo que deberías poder traducir el conocimiento de forma natural. La principal diferencia es el prefijo: `str_` vs `stri_`.

## forcats

En R, los factores se usan para trabajar con variables categóricas, variables que tienen un conjunto fijo y conocido de valores posibles. También son útiles cuando queremos mostrar vectores de caracteres en un orden no alfabético.

Históricamente, los factores eran mucho más fáciles de trabajar que los caracteres. Como resultado, muchas de las funciones de R base automáticamente convierten los caracteres en factores. Esto significa que los factores a menudo surgen en lugares donde no son realmente útiles.

Para trabajar con factores, usaremos el paquete `forcats`, que proporciona herramientas para trabajar con variables categóricas. Proporciona una amplia gama de ayudantes para trabajar con factores. `forcats` no es parte del tidyverse central, por lo que debemos cargarlo explícitamente.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(forcats)
```


### Creando factores

Imaginemos que tenemos una variable que registra el mes:

```{r, message=FALSE, warning=FALSE}
x1 <- c("Dec", "Apr", "Jan", "Mar")
```


Usar una cadena para registrar esta variable tiene dos problemas:

1. Solo hay doce meses posibles y no hay nada que nos salve de los errores tipográficos:

```{r, message=FALSE, warning=FALSE}
x2 <- c("Dec", "Apr", "Jam", "Mar")
```


2. No ordena de una manera útil:

```{r, message=FALSE, warning=FALSE}
sort(x1)
```

Podemos solucionar ambos problemas con un factor. Para crear un factor, debemos comenzar creando una lista de los niveles válidos:

```{r, message=FALSE, warning=FALSE}
month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
```

Ahora podemos crear un factor:

```{r, message=FALSE, warning=FALSE}
y1 <- factor(x1, levels = month_levels)
y1

sort(y1)
```

Y cualquier valor que no esté en el conjunto se convertirá silenciosamente a `NA`:

```{r, message=FALSE, warning=FALSE}
y2 <- factor(x2, levels = month_levels)
y2
```

Si omitimos los niveles, se tomarán de los datos en orden alfabético:

```{r, message=FALSE, warning=FALSE}
factor(x1)
```

A veces preferiremos que el orden de los niveles coincida con el orden de la primera aparición en los datos. Podemos hacerlo al crear el factor estableciendo niveles a `unique(x)`, o después del factor, con `fct_inorder()`:

```{r, message=FALSE, warning=FALSE}
f1 <- factor(x1, levels = unique(x1))
f1

f2 <- x1 %>% factor() %>% fct_inorder()
f2
```


Si alguna vez necesitamos acceder al conjunto de niveles válidos directamente, podemos hacerlo con `levels()`:

```{r, message=FALSE, warning=FALSE}
levels(f2)
```

### Encuesta social general

Usaremos `forcats::gss_cat`. Es una muestra de datos de la [Encuesta Social General](http://gss.norc.org/), que es una encuesta realizada en Estados unidos por la organización de investigación independiente **NORC** de la **Universidad de Chicago**. La encuesta tiene miles de preguntas, en `gss_cat` se encuentran algunas que ilustrarán algunos desafíos comunes que encontramos al trabajar con factores.

```{r, message=FALSE, warning=FALSE}
gss_cat
```

Cuando los factores se almacenan en un `tibble`, no podemos ver sus niveles tan fácilmente. Una forma de verlos es con `count()`:

```{r, message=FALSE, warning=FALSE}
gss_cat %>%
  count(race)
```

O con una gráfica de barras:

```{r, message=FALSE, warning=FALSE}
ggplot(gss_cat, aes(race)) +
  geom_bar()
```

Por defecto, `ggplot2` soltará niveles que no tienen ningún valor. Podemos obligarlo a mostrarlos con:

```{r, message=FALSE, warning=FALSE}
ggplot(gss_cat, aes(race)) +
  geom_bar() +
  scale_x_discrete(drop = FALSE)
```

Estos niveles representan valores válidos que simplemente no ocurrieron en este conjunto de datos.

Al trabajar con factores, las dos operaciones más comunes cambian el orden de los niveles y cambian los valores de los niveles.

### Modificación de orden de los factores

A menudo es útil cambiar el orden de los niveles de los factores en una visualización. Por ejemplo, imagina que queremos explorar el promedio de horas dedicadas a ver televisión por día en diferentes religiones:

```{r, message=FALSE, warning=FALSE}
relig_summary <- gss_cat %>%
  group_by(relig) %>%
  summarise(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(relig_summary, aes(tvhours, relig)) + geom_point()
```

Es difícil interpretar esta gráfica porque no hay un patrón general. Podemos mejorarlo reordenando los niveles de `relig` usando `fct_reorder()`. `fct_reorder()` toma tres argumentos:

+ `f`, el factor cuyos niveles queremos modificar
+ `x`, un vector numérico que deseamos usar para reordenar los niveles.
+ Opcionalmente, `fun` una función que se usa si hay múltiples valores de `x` para cada valor de `f`. El valor predeterminado es `median`.

```{r, message=FALSE, warning=FALSE}
ggplot(relig_summary, aes(tvhours, fct_reorder(relig, tvhours))) +
  geom_point()
```

Reordenar la religión hace que sea mucho más fácil ver que las personas de la categoría "No sé" ven mucha más televisión, y el Hinduismo y otras religiones orientales ven mucho menos.

A medida que comenzamos a hacer transformaciones más complicadas, es recomendable moverlas de `aes()` a un `mutate()` por separado. Por ejemplo, podríamos reescribir la gráfica anterior como:

```{r, message=FALSE, warning=FALSE}
relig_summary %>%
  mutate(relig = fct_reorder(relig, tvhours)) %>%
  ggplot(aes(tvhours, relig)) +
    geom_point()
```

¿Qué pasa si creamos una gráfica similar mirando cómo varía la edad promedio a través del nivel de ingresos reportados?

```{r, message=FALSE, warning=FALSE}
rincome_summary <- gss_cat %>%
  group_by(rincome) %>%
  summarise(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(rincome_summary, aes(age, fct_reorder(rincome, age))) + geom_point()
```

¡Aquí, reordenar arbitrariamente los niveles no es una buena idea! Eso es porque `rincome` ya tiene un orden principal con el que no deberíamos meternos. Reservemos `fct_reorder()` para factores cuyos niveles se ordenan arbitrariamente.

Sin embargo, tiene sentido tirar "No aplicable" al frente con los otros niveles especiales. Podemos usar `fct_relevel()`. Toma un factor, `f` y luego cualquier cantidad de niveles que deseemos mover al frente de la línea.

```{r, message=FALSE, warning=FALSE, include=TRUE, eval=FALSE}
ggplot(rincome_summary, 
       aes(age, fct_relevel(rincome, "Not applicable")))
+ geom_point()
```

![](../images/graph1.png)

¿Por qué crees que la edad promedio para "No aplicable" es tan alta?

Otro tipo de reordenamiento es útil cuando se colorean las líneas en un diagrama. `fct_reorder2()` reordena el factor por los valores `y` asociados con los valores `x` más grandes. Esto hace que la gráfica sea más fácil de leer porque los colores de la línea se alinean con la leyenda.

```{r, message=FALSE, warning=FALSE}
by_age <- gss_cat %>%
  filter(!is.na(age)) %>%
  count(age, marital) %>%
  group_by(age) %>%
  mutate(prop = n / sum(n))

ggplot(by_age, aes(age, prop, colour = marital)) +
  geom_line(na.rm = TRUE)

ggplot(by_age, 
       aes(age, prop, colour = fct_reorder2(marital, age, prop))) +
  geom_line() +
  labs(colour = "marital")
```

Finalmente, para gráficas de barra, podemos usar `fct_infreq()` para ordenar niveles en frecuencia creciente: este es el tipo más simple de reordenamiento porque no necesita ninguna variable adicional. Es posible que necesitemos combinar con `fct_rev()`.

```{r, message=FALSE, warning=FALSE}
gss_cat %>%
  mutate(marital = marital %>% fct_infreq() %>% fct_rev()) %>%
  ggplot(aes(marital)) +
    geom_bar()
```

### Modificación de niveles de factores

Más poderoso que cambiar las órdenes de los niveles es cambiar sus valores. Esto nos permite aclarar las etiquetas para nuestra publicación y los niveles de contracción para las pantallas de alto nivel. La herramienta más general y poderosa es `fct_recode()`. Nos permite recodificar o cambiar el valor de cada nivel. Por ejemplo, tomemos el `gss_cat$partyid`:

```{r, message=FALSE, warning=FALSE}
gss_cat %>% count(partyid)
```

Los niveles son escuetos e inconsistentes. Vamos a ajustarlos para que sean más largos y usar una construcción paralela.

```{r, message=FALSE, warning=FALSE}
gss_cat %>%
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat"
  )) %>%
  count(partyid)
```

`fct_recode()` dejará los niveles que no se mencionan explícitamente tal como están y nos advertirá si nos estamos refiriendo accidentalmente a un nivel que no existe.

Para combinar grupos, podemos asignar múltiples niveles antiguos al mismo nivel nuevo:

```{r, message=FALSE, warning=FALSE}
gss_cat %>%
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat",
    "Other"                 = "No answer",
    "Other"                 = "Don't know",
    "Other"                 = "Other party"
  )) %>%
  count(partyid)
```

Debemos usar esta técnica con cuidado: si agrupamos categorías que son realmente diferentes, terminaremos con resultados engañosos.

Si queremos colapsar muchos niveles, `fct_collapse()` es una variante útil de `fct_recode()`. Para cada nueva variable, podemos proporcionar un vector de niveles antiguos:

```{r, message=FALSE, warning=FALSE}
gss_cat %>%
  mutate(partyid = fct_collapse(partyid,
    other = c("No answer", "Don't know", "Other party"),
    rep = c("Strong republican", "Not str republican"),
    ind = c("Ind,near rep", "Independent", "Ind,near dem"),
    dem = c("Not str democrat", "Strong democrat")
  )) %>%
  count(partyid)
```

A veces solo queremos agrupar a todos los grupos pequeños para simplificar un diagrama o una tabla. Ese es el trabajo de `fct_lump()`:

```{r, message=FALSE, warning=FALSE}
gss_cat %>%
  mutate(relig = fct_lump(relig)) %>%
  count(relig)
```

El comportamiento predeterminado es agrupar progresivamente los grupos más pequeños, asegurando que el agregado sigue siendo el grupo más pequeño. En este caso no es muy útil: es cierto que la mayoría de los estadounidenses en esta encuesta son protestantes, pero es probable colapsemos de más.

En cambio, podemos usar el parámetro `n` para especificar cuántos grupos (excluyendo otros) queremos mantener:

```{r, message=FALSE, warning=FALSE}
gss_cat %>%
  mutate(relig = fct_lump(relig, n = 10)) %>%
  count(relig, sort = TRUE) %>%
  print(n = Inf)
```

## lubridate

A primera vista, las fechas y las horas parecen simples. Los usamos todo el tiempo en la vida normal, y no parecen causar mucha confusión. Sin embargo, cuanto más aprendes sobre fechas y horarios, más complicados parecen obtenerlos. Para calentar, probemos estas tres preguntas aparentemente simples:

+ ¿Todos los años tienen 365 días?
+ ¿Todos los días tienen 24 horas?
+ ¿Cada minuto tiene 60 segundos?

Sabemos que no todos los años tienen 365 días, pero ¿conoces la regla completa para determinar si un año es bisiesto? Es posible que recordemos que muchas partes del mundo usan el horario de verano (DST), por lo que algunos días tienen 23 horas y otros tienen 25. Es posible que no sepamos que algunos minutos tienen 61 segundos porque de vez en cuando se agregan segundos intercalares porque la rotación de la Tierra se está desacelerando gradualmente.

Las fechas y los tiempos son difíciles porque tienen que conciliar dos fenómenos físicos (la rotación de la Tierra y su órbita alrededor del sol) con una gran cantidad de fenómenos geopolíticos que incluyen meses, zonas horarias y horario de verano.

Usaremos el paquete `lubridate`, que facilita el trabajo con fechas y horas en R. `lubridate` no forma parte del `tidyverse`. Usaremos la base que ya conocemos `nycflights13` para practicar.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(lubridate)
library(nycflights13)
```


### Creación de fecha/hora

Hay tres tipos de datos de fecha/hora que se refieren a un instante en el tiempo:

+ Una **fecha**. Tibbles imprime esto como `<date>`.

+ Una **hora** del día. Tibbles imprime esto como `<time>`.

+ Una **fecha-hora** es una fecha más una hora: identifica de manera única un instante en el tiempo (generalmente al segundo más cercano). Tibbles imprime esto como `<dttm>`.

Siempre debemos usar el tipo de datos más simple posible que funcione para nuestras necesidades. Eso significa que si podemos usar una fecha en lugar de una fecha-hora, deberíamos hacerlo. Los horarios son sustancialmente más complicados debido a la necesidad de manejar zonas horarias.

Para obtener la fecha actual o la fecha-hora, usamos `today()` o `now()`:

```{r, message=FALSE, warning=FALSE}
today()

now()
```

De lo contrario, hay tres formas en las que es probable que creemos una fecha/hora:

+ De una cadena de texto.
+ A partir de componentes individuales de fecha-hora.
+ Desde un objeto de fecha/hora existente.

Funcionan de la siguiente manera.

#### De cadenas

Los datos de fecha/hora a menudo vienen como cadenas. Podemos usar los ayudantes provistos por `lubridate` para transformarlas en formato de fecha-hora. Automáticamente resuelven el formato una vez que especificamos el orden del componente. Para usarlos, debemos identificar el orden en que aparecen el año, el mes y el día en las fechas, luego organizar "y", "m" y "d" en el mismo orden. Eso nos da el nombre de la función de lubridate que parseara la fecha. Por ejemplo:

```{r, message=FALSE, warning=FALSE}
ymd("2017-01-31")

mdy("January 31st, 2017")

dmy("31-Jan-2017")
```

Estas funciones también toman números sin comillas. Esta es la forma más concisa de crear un único objeto de fecha/hora, como puede ser necesario al filtrar datos de fecha/hora. `ymd()` es corto e inequívoco:

```{r, message=FALSE, warning=FALSE}
ymd(20170131)
```

`ymd()` y sus amigos crean fechas. Para crear una fecha y hora, agregamos un guión bajo y una o más de "h", "m" y "s" al nombre de la función de análisis sintáctico:

```{r, message=FALSE, warning=FALSE}
ymd_hms("2017-01-31 20:11:59")

mdy_hm("01/31/2017 08:01")
```

También podemos forzar la creación de una fecha y hora a partir de una fecha proporcionando una zona horaria:

```{r, message=FALSE, warning=FALSE}
ymd(20170131, tz = "UTC")
```

#### De componentes individuales

En lugar de una sola cadena, a veces tendremos los componentes individuales de la fecha y hora distribuidos en varias columnas. Esto es lo que tenemos en los datos de vuelos:

```{r}
flights %>% 
  select(year, month, day, hour, minute)
```

Para crear una fecha/hora a partir de este tipo de entrada, usamos `make_date()` para fechas o `make_datetime()` fechas-horas:

```{r}
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

Hagamos lo mismo para cada una de las cuatro columnas de tiempo en `flights`. Los tiempos están representados en un formato ligeramente extraño, por lo que usamos la aritmética de módulo para extraer los componentes de hora y minuto.

```{r}
make_datetime_100 <- function(year, month, day, time) {
  make_datetime(year, month, day, time %/% 100, time %% 100)
}

flights_dt <- flights %>% 
  filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(
    dep_time = make_datetime_100(year, month, day, dep_time),
    arr_time = make_datetime_100(year, month, day, arr_time),
    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),
    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)
  ) %>% 
  select(origin, dest, ends_with("delay"), ends_with("time"))

flights_dt
```

Con estos datos, podemos visualizar la distribución de los horarios de salida a lo largo del año:

```{r}
flights_dt %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 86400) # 86400 segundos = 1 día
```


O en un solo día:

```{r}
flights_dt %>% 
  filter(dep_time < ymd(20130102)) %>% 
  ggplot(aes(dep_time)) + 
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutos
```

Notemos que cuando utilizamos fechas y horas en un contexto numérico (como en un histograma), 1 significa 1 segundo, por lo que un ancho de 86400 equivale a un día. Para las fechas, 1 significa 1 día.

#### De otros tipos

Es posible que deseemos cambiar entre una fecha-hora y una fecha. Para eso, usamos `as_datetime()` y `as_date()`:

```{r}
as_datetime(today())

as_date(now())
```

Algunas veces obtendremos fecha/hora como compensaciones numéricas del "Unix Epoch", 1970-01-01. Si el desplazamiento está en segundos, usamos `as_datetime()` si es en días, usamos `as_date()`.

```{r}
as_datetime(60 * 60 * 10)

as_date(365 * 10 + 2)
```

### Componentes de fecha y hora

Ahora que sabemos cómo obtener datos de fecha y hora en las estructuras de datos de fecha y hora de R, exploremos qué podemos hacer con ellos.

#### Obteniendo componentes

Podemos sacar las piezas individuales de la fecha con las funciones de acceso `year()`, `month()`, `mday()` (día del mes), `yday()` (los días del año), `wday()` (día de la semana), `hour()`, `minute()`, y `second()`.

```{r}
datetime <- ymd_hms("2016-07-08 12:34:56")

year(datetime)

month(datetime)

mday(datetime)


yday(datetime)

wday(datetime)
```

Para `month()` y `wday()` podemos configurar `label = TRUE` para devolver el nombre abreviado del mes o el día de la semana. También podemos establecer `abbr = FALSE` para devolver el nombre completo.

```{r}
month(datetime, label = TRUE)

wday(datetime, label = TRUE, abbr = FALSE)
```

Podemos utilizar `wday()` para ver que más vuelos salen durante la semana que en el fin de semana:

```{r}
flights_dt %>% 
  mutate(wday = wday(dep_time, label = TRUE)) %>% 
  ggplot(aes(x = wday)) +
    geom_bar()
```

Hay un patrón interesante si observamos el retraso promedio de salida por minuto dentro de una hora. ¡Parece que los vuelos que salen en minutos 20-30 y 50-60 tienen retrasos mucho más bajos que el resto de la hora!

```{r}
flights_dt %>% 
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()) %>% 
  ggplot(aes(minute, avg_delay)) +
    geom_line()
```

Curiosamente, si vemos la hora programada de salida, no vemos un patrón tan fuerte:

```{r}
sched_dep <- flights_dt %>% 
  mutate(minute = minute(sched_dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n())

ggplot(sched_dep, aes(minute, avg_delay)) +
  geom_line()
```

Entonces, ¿por qué vemos ese patrón con los tiempos reales de salida? Bueno, al igual que muchos datos recopilados por humanos, hay un fuerte sesgo hacia los vuelos que salen en tiempos de salida "agradables". Siempre debemos estar atentos a este tipo de patrón cuando trabajemos con datos que involucren el juicio humano.

```{r}
ggplot(sched_dep, aes(minute, n)) +
  geom_line()
```

#### Redondeo

Un enfoque alternativo para graficar los componentes individuales es redondear la fecha a una unidad cercana de tiempo, con `floor_date()`, `round_date()`, y `ceiling_date()`. Cada función toma un vector de fechas para ajustar y redondear. Esto, por ejemplo, nos permite graficar el número de vuelos por semana:

```{r, message=FALSE, warning=FALSE}
flights_dt %>% 
  count(week = floor_date(dep_time, "week")) %>% 
  ggplot(aes(week, n)) +
    geom_line()
```

#### Configuración de componentes

También podemos usar cada función para configurar los componentes de una fecha/hora:

```{r, message=FALSE, warning=FALSE}
(datetime <- ymd_hms("2016-07-08 12:34:56"))

year(datetime) <- 2020
datetime

month(datetime) <- 01
datetime

hour(datetime) <- hour(datetime) + 1
datetime
```

Alternativamente, en lugar de modificar, podemos crear una nueva fecha y hora con `update()`. Esto también nos permite establecer múltiples valores a la vez.

```{r, message=FALSE, warning=FALSE}
update(datetime, year = 2020, month = 2, mday = 2, hour = 2)
```

Si los valores son demasiado grandes, se reiniciarán:
  
```{r, message=FALSE, warning=FALSE}
ymd("2015-02-01") %>% 
  update(mday = 30)

ymd("2015-02-01") %>% 
  update(hour = 400)
```

Podemos usar `update()` para mostrar la distribución de vuelos a lo largo del día para cada día del año:

```{r, message=FALSE, warning=FALSE}
flights_dt %>% 
  mutate(dep_hour = update(dep_time, yday = 1)) %>% 
  ggplot(aes(dep_hour)) +
    geom_freqpoly(binwidth = 300)
```

### Lapso de tiempo

Veremos tres clases importantes que representan períodos de tiempo:

+ **durations**, que representan una cantidad exacta de segundos.
+ **periods**, que representan unidades humanas como semanas y meses.
+ **intervals**, que representan un punto inicial y final.

#### Duraciones

En R, cuando restamos dos fechas, obtenemos un objeto de tiempo `difftime`:

```{r, message=FALSE, warning=FALSE}
age <- today() - ymd(19880813)
age
```

Un objeto de clase `difftime` registra un lapso de tiempo de segundos, minutos, horas, días o semanas. Esta ambigüedad puede hacer que sea un poco doloroso trabajar con él, por lo que `lubridate` proporciona una alternativa que siempre usa segundos: la **duración**.

```{r, message=FALSE, warning=FALSE}
as.duration(age)
```

Las duraciones vienen con un grupo de constructores convenientes:

```{r, message=FALSE, warning=FALSE}
dseconds(15)
dminutes(10)
dhours(c(12, 24))
ddays(0:5)
dweeks(3)
dyears(1)
```

Las duraciones siempre registran el lapso de tiempo en segundos. Las unidades más grandes se crean mediante la conversión de minutos, horas, días, semanas y años a segundos a las tasas estándar (60 segundos en un minuto, 60 minutos en una hora, 24 horas en día, 7 días a la semana, los 365 días en un año).

Podemos sumar y multiplicar duraciones:

```{r, message=FALSE, warning=FALSE}
2 * dyears(1)
dyears(1) + dweeks(12) + dhours(15)
```

Podemos sumar y restar duraciones desde y a días:

```{r, message=FALSE, warning=FALSE}
tomorrow <- today() + ddays(1)
last_year <- today() - dyears(1)
```

Sin embargo, dado que las duraciones representan una cantidad exacta de segundos, a veces podemos obtener un resultado inesperado:

```{r, message=FALSE, warning=FALSE}
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")
one_pm
one_pm + ddays(1)
```

¿Por qué un día después de la 1 pm el 12 de marzo no da las 2 pm el 13 de marzo? Si observamos detenidamente la fecha, también podemos notar que las zonas horarias han cambiado. Debido al horario de verano, el 12 de marzo solo tiene 23 horas, por lo que si agregamos días en segundos, terminamos con un horario diferente.

#### Períodos

Para resolver este problema, `lubridate` proporciona **periodos**. Los períodos son períodos de tiempo, pero no tienen una duración fija en segundos, sino que funcionan con tiempos "humanos", como días y meses. Eso les permite trabajar de una manera más intuitiva:

```{r, message=FALSE, warning=FALSE}
one_pm
one_pm + days(1)
```

Al igual que las duraciones, los períodos se pueden crear con varias funciones amigables.

```{r, message=FALSE, warning=FALSE}
seconds(15)
minutes(10)
hours(c(12, 24))
days(7)
months(1:6)
weeks(3)
years(1)
```

Podemos sumar y multiplicar periodos:

```{r, message=FALSE, warning=FALSE}
10 * (months(6) + days(1))
days(50) + hours(25) + minutes(2)
```

Y, por supuesto, sumarlos a las fechas. En comparación con las duraciones, los períodos tienen más probabilidades de hacer lo que esperamos:

```{r, message=FALSE, warning=FALSE}
# Un año bisiesto
ymd("2016-01-01") + dyears(1)
ymd("2016-01-01") + years(1)

# Horario de Verano
one_pm + ddays(1)
one_pm + days(1)
```

Usemos períodos para arreglar una rareza relacionada con nuestras fechas de vuelo. Algunos aviones parecen haber llegado a su destino antes de partir de la ciudad de Nueva York.

```{r, message=FALSE, warning=FALSE}
flights_dt %>% 
  filter(arr_time < dep_time)
```

Estos son vuelos nocturnos. Utilizamos la misma información de fecha tanto para la hora de salida como para la hora de llegada, pero estos vuelos llegaron al día siguiente. Podemos solucionar esto añadiendo `days(1)` al tiempo de llegada de cada vuelo nocturno.

```{r, message=FALSE, warning=FALSE}
flights_dt <- flights_dt %>% 
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight * 1),
    sched_arr_time = sched_arr_time + days(overnight * 1)
  )
```

Ahora todos nuestros vuelos obedecen las leyes de la física.

```{r, message=FALSE, warning=FALSE}
flights_dt %>% 
  filter(overnight, arr_time < dep_time)
```

#### Intervalos

Es obvio lo que `dyears(1) / ddays(365)` debería regresar: uno, porque las duraciones siempre están representadas por una cantidad de segundos, y una duración de un año se define como 365 días en segundos.

¿Qué debería regresar `years(1) / days(1)`? 

Si el año fue 2015 debería devolver 365, pero si fuera 2016, ¡debería devolver 366! No hay suficiente información para que `lubridate` brinde una única respuesta clara. Lo que hace en cambio es dar una estimación, con una advertencia:

```{r}
years(1) / days(1)
```

Si queremos una medida más precisa, usamos un **intervalo**. Un intervalo es una duración con un punto de inicio, eso lo hace preciso para que podamos determinar exactamente cuánto tiempo es:

```{r, message=FALSE, warning=FALSE}
next_year <- today() + years(1)
(today() %--% next_year) / ddays(1)
```

Para saber cuántos períodos entran en un intervalo, debemos usar la división de enteros:

```{r, message=FALSE, warning=FALSE}
(today() %--% next_year) %/% days(1)
```

#### Resumen

¿Cómo se elige entre duración, períodos e intervalos? Como siempre, elegimos la estructura de datos más simple que resuelva nuestro problema. Si solo nos importa el tiempo físico, usamos una duración; si necesitamos agregar tiempos humanos, usamos un período; si necesitamos saber cuánto tiempo dura un lapso en unidades humanas, usamos un intervalo.

Las operaciones aritméticas permitidas entre pares de clases de fecha/hora:

![](../images/datetimes-arithmetic.png)

### Zonas horarias

Las zonas horarias son un tema enormemente complicado debido a su interacción con entidades geopolíticas. Afortunadamente, no necesitamos profundizar en todos los detalles, ya que no son todos importantes para el análisis de datos, pero hay algunos desafíos que debemos enfrentar.

El primer desafío es que los nombres diarios de las zonas horarias tienden a ser ambiguos. Por ejemplo, los estadounidenses, están familiarizados con EST o Eastern Standard Time. Sin embargo, tanto Australia como Canadá también tienen EST. Para evitar confusiones, R usa las zonas horarias estándar internacionales de IANA. Estos usan un esquema de nombres consistente `"/"`, típicamente en la forma `"<continente>/<ciudad>"` (hay algunas excepciones porque no todos los países se encuentran en un continente). Los ejemplos incluyen `"America/New_York"`, `"Europe/Paris"` y `"Pacific/Auckland"`.

Podemos descubrir lo que piensa R que es nuestra zona horaria actual con `Sys.timezone()`:

```{r, message=FALSE, warning=FALSE}
Sys.timezone()
```

(Si R no sabe, obtendremos un `NA`.)

Vemos la lista completa de todos los nombres de zona horaria con `OlsonNames()`:

```{r, message=FALSE, warning=FALSE}
length(OlsonNames())
head(OlsonNames())
```

En R, la zona horaria es un atributo de la fecha y hora que solo controla la impresión. Por ejemplo, estos tres objetos representan el mismo instante en el tiempo:

```{r, message=FALSE, warning=FALSE}
(x1 <- ymd_hms("2015-06-01 12:00:00", tz = "America/New_York"))
(x2 <- ymd_hms("2015-06-01 18:00:00", tz = "Europe/Copenhagen"))
(x3 <- ymd_hms("2015-06-02 04:00:00", tz = "Pacific/Auckland"))
```

Podemos verificar que son el mismo tiempo restando:

```{r, message=FALSE, warning=FALSE}
x1 - x2
x1 - x3
```

A menos que se especifique lo contrario, `lubridate` siempre usa UTC. UTC (tiempo universal coordinado) es la zona horaria estándar utilizada por la comunidad científica y más o menos equivalente a su predecesor, GMT (Greenwich Mean Time). No tiene horario de verano, lo que la hace una representación conveniente para cálculos. Las operaciones que combinan fechas y horas, como `c()`, a menudo ignorarán la zona horaria. En ese caso, los horarios se mostrarán en nuestra zona horaria local:

```{r, message=FALSE, warning=FALSE}
x4 <- c(x1, x2, x3)
x4
```

Podemos cambiar la zona horaria de dos maneras:

+ Mantener el mismo instante en tiempo y cambiar la forma en que se muestra. Usamos esto cuando el instante es correcto, pero deseamos una visualización más natural.

```{r, message=FALSE, warning=FALSE}
x4a <- with_tz(x4, tzone = "Australia/Lord_Howe")
x4a
x4a - x4
```


+ Cambiar el instante subyacente en tiempo. Usamos esto cuando tenemos un instante que haya sido etiquetado con la zona horaria incorrecta y necesitamos repararlo.

```{r, message=FALSE, warning=FALSE}
x4b <- force_tz(x4, tzone = "Australia/Lord_Howe")
x4b
x4b - x4
```

## Ejercicios

### stringr

1. A menudo verás `paste()` y `paste0()`. ¿Cuál es la diferencia entre las dos funciones? ¿A qué función de `stringr` son equivalentes? ¿Cómo difieren las funciones en su manejo de `NA`?

2. En tus propias palabras, describe la diferencia entre los argumentos `sep` y `collapse` de `str_c()`.

3. Usa `str_length()` y `str_sub()` para extraer el caracter medio de una cadena. ¿Qué harás si la cadena tiene un número par de caracteres?

4. ¿Qué hace `str_wrap()`? ¿Cuándo podrías querer usarlo?

5. ¿Qué hace `str_trim()`? ¿Qué es lo opuesto a `str_trim()`?

6. Escribe una función que convierta (por ejemplo) un vector `c("a", "b", "c")` en la cadena `a, b y c`. Piensa con cuidado sobre lo que debería hacer esta función si recibe un vector de longitud 0, 1 o 2.

7. Explica por qué cada una de estas cadenas no coinciden con un `\`: `"\"`, `"\\"`, `"\\\"`.

8. ¿Cómo coincidirías la secuencia `"'\`?

9. ¿Qué patrones encontrará la expresión regular `\..\..\..`? ¿Cómo lo representarías como una cadena?

10. ¿Cómo coincidirías con la cadena literal `"$^$"`?

11. Dado el corpus de palabras en `stringr::words`, crea expresiones regulares que encuentren todas las palabras que:

    + Comienzan con "y".
    + Terminan con "x"
    + Tienen exactamente tres letras de largo. (¡No hagas trampa al usar str_length()!)
    + Tener siete letras o más.
    
Dado que esta lista es larga, es posible que desees utilizar el argumento `match` de `str_view()` para mostrar solo las palabras coincidentes o no coincidentes.

12. Crea expresiones regulares para encontrar todas las palabras que:

    + Comienzan con una vocal.
    + Solo contienen consonantes. (Sugerencia: piensa en encontrar "no" -vocales).
    + Terminan con `ed`, pero no con `eed`.
    + Terminan con `ing` o `ise`.

13. Crea una expresión regular que coincida con los números de teléfono escritos comúnmente en tu país.

14. Describe los equivalentes de `?`, `+`, `*` en la forma `{m,n}`.

15. Crea expresiones regulares para encontrar todas las palabras que:

    + Comienzan con tres consonantes.
    + Tienen tres o más vocales seguidas.
    + Tienen dos o más parejas de vocales y consonantes seguidas.
    + Resuelve los crucigramas de la expresión regular para principiantes en [https://regexcrossword.com/challenges/beginner](https://regexcrossword.com/challenges/beginner).

16. Construya expresiones regulares para unir palabras que:

    + Comienzan y terminan con el mismo caracter.
    + Contienen un par de letras repetidas (por ejemplo, "church" contiene "ch" repetido dos veces).
    + Contienen una letra repetida en al menos tres lugares (por ejemplo, "eleven" contiene tres "e").

17. Para cada uno de los siguientes desafíos, intenta resolverlo utilizando una sola expresión regular y una combinación de llamadas múltiples a `str_detect()`.

    + Encuentra todas las palabras que comienzan o terminan llamadas múltiples`x`.
    + Encuentra todas las palabras que comienzan con una vocal y terminan con una consonante.
    + ¿Hay alguna palabra que contenga al menos una de cada vocal diferente?

18. ¿Qué palabra tiene el mayor número de vocales? ¿Qué palabra tiene la mayor proporción de vocales? (Sugerencia: ¿cuál es el denominador?)

1. Encuentra todas las palabras que vienen después de un "número" como "uno", "dos", "tres", etc. Saca el número y la palabra (en inglés).

2. Encuentra todas las contracciones. Separa las piezas antes y después del apóstrofe.

1. Reemplaza todas las barras diagonales en una cadena con barras diagonales inversas.

2. Implementa una versión simple de `str_to_lower()` usando `replace_all()`.

3. Cambia la primera y la última letra en `words`. ¿Cuáles de esas cadenas son todavía palabras?

1. Divide una cadena como "apples, pears, and bananas" en componentes individuales.

2. ¿Por qué es mejor dividir con `boundary("word")` que con `" "`?

3. ¿Qué hace la división con una cadena vacía (`""`)? Experimenta y luego lee la documentación.

1. ¿Cuáles son las cinco palabras más comunes en `sentences`?

1. Encuentra las funciones de stringi que:
    
    + Cuenta el número de palabras.
    + Encuentra cadenas duplicadas.
    + Genera texto aleatorio.
    
2. ¿Cómo controlas el lenguaje que `stri_sort()` usa para ordenar?

### forcats

1. Explora la distribución de `rincome` en `forcats::gss_cat` (ingreso reportado). ¿Qué hace que la gráfica de barras predeterminada sea difícil de entender? ¿Cómo podrías mejorarla?

2. ¿Cuál es el más común `relig` en esta encuesta? ¿Cuál es el más común `partyid`?

1. Hay algunos números sospechosamente altos en `tvhours`. ¿Es la media un buen resumen?

2. Para cada factor en `gss_cat` identifica si el orden de los niveles es arbitrario o principal.

3. ¿Por qué mover "No aplicable" de `rincome` al frente de los niveles lo mueve al final de la gráfica?

1. ¿Cómo han cambiado con el tiempo las proporciones de personas que se identifican como demócratas, republicanos e independientes?

2. ¿Cómo podrías colapsar `rincome` en un pequeño conjunto de categorías?

### lubridate

1. ¿Qué sucede si parseas una cadena que contiene fechas no válidas?

```{r, message=FALSE, warning=FALSE, eval=FALSE, include=TRUE}
ymd(c("2010-10-10", "bananas"))
```

2. ¿Qué hace el argumento `tzone` para `today()`? ¿Por qué es importante?

3. Use la función de `lubridate` apropiada para parsear cada una de las siguientes fechas:

```{r, message=FALSE, warning=FALSE, eval=FALSE, include=TRUE}
d1 <- "January 1, 2010"
d2 <- "2015-Mar-07"
d3 <- "06-Jun-2017"
d4 <- c("August 19 (2015)", "July 1 (2015)")
d5 <- "12/30/14" # 30 Dic, 2014
```

4. ¿Cómo cambia la distribución de los tiempos de vuelo en un día a lo largo del año?

5. Compara `dep_time`, `sched_dep_time` y `dep_delay`. ¿Son consistentes? Explica tus hallazgos

6. Compara `air_time` con la duración entre la partida y la llegada. Explica tus hallazgos (Sugerencia: considera la ubicación del aeropuerto).

7. ¿Cómo cambia el tiempo promedio de demora en el transcurso de un día? ¿Deberías usar `dep_time` o `sched_dep_time`? ¿Por qué?

8. ¿En qué día de la semana deberías irte si quieres minimizar la posibilidad de un retraso?

9. ¿Qué hace la distribución de `diamonds$carat` y `flights$sched_dep_time` similares?

10. Confirma la hipótesis de que las salidas anticipadas de los vuelos en los minutos 20-30 y 50-60 son causadas por vuelos programados que salen temprano. Sugerencia: crea una variable binaria que te diga si un vuelo se retrasó o no.

11. ¿Cómo explicarías `days(overnight * 1)` a alguien que acaba de comenzar a aprender R? ¿Cómo funciona?

12. Crea un vector de fechas para el primer día de cada mes en 2015. Crea un vector de fechas que indique el primer día de cada mes en el año actual.

13. Escribe una función que, dada tu fecha de cumpleaños (como fecha), devuelva la edad que tienes en años.

14. ¿Por qué no funciona `(today() %--% (today() + years(1)) / months(1)`?